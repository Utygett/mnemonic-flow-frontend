
==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\App.tsx
==============================

import React from 'react';

import { AuthProvider } from './auth/AuthContext';
import { AuthGate } from './auth/AuthGate';

import { AppRouter } from './app/AppRouter';
import { MainShellContainer } from './screens/main';

export default function App() {
  return (
    <AuthProvider>
      <AppRouter
        renderMain={() => (
          <AuthGate>
            <MainShellContainer />
          </AuthGate>
        )}
      />
    </AuthProvider>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\index.html
==============================

<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
  <meta name="theme-color" content="#4A6FA5">
  <meta name="description" content="Образовательное приложение с карточками и интервальным повторением">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="MenmonicFlow">
  
  <title>MenmonicFlow - Обучение по карточкам</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">
  
  <!-- Favicons -->
  <link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="/icon-512.png">
  <link rel="apple-touch-icon" href="/icon-192.png">
  
  <style>
    /* Prevent pull-to-refresh on mobile */
    body {
      overscroll-behavior-y: contain;
    }
    
    /* iOS Safe Area Support */
    body {
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <!-- Service Worker Registration -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then((registration) => {
            console.log('ServiceWorker registration successful:', registration.scope);
          })
          .catch((error) => {
            console.log('ServiceWorker registration failed:', error);
          });
      });
    }
  </script>
</body>
</html>




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\main.tsx
==============================


  import { createRoot } from "react-dom/client";
  import App from "./App.tsx";
  import "./styles/globals.css";
  import "./styles/components.css";
  import 'katex/dist/katex.min.css';

  createRoot(document.getElementById("root")!).render(<App />);
  



==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\api\authClient.ts
==============================

// src/api/authClient.ts

const API_URL = '/api';

function extractFastApiError(payload: any, fallback: string) {
  const detail = payload?.detail;

  // HTTPException: detail строкой или объектом {code,message}
  if (typeof detail === 'string') return detail;
  if (detail && typeof detail === 'object' && !Array.isArray(detail)) {
    return detail.message ?? JSON.stringify(detail);
  }

  // RequestValidationError: detail = массив ошибок
  if (Array.isArray(detail) && detail.length > 0) {
    const first = detail[0];
    const field =
      Array.isArray(first?.loc) ? first.loc.slice(-1)[0] : 'field';
    const msg = first?.msg ?? 'Validation error';
    return `${field}: ${msg}`;
  }

  return fallback;
}



export async function register(email: string, password: string) {
  const res = await fetch(`${API_URL}/auth/register`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password }),
  });

  const rawText = await res.text();
  let payload: any = null;
  try {
    payload = rawText ? JSON.parse(rawText) : null;
  } catch {
    payload = null;
  }

  if (!res.ok) {
    throw new Error(extractFastApiError(payload, `Register failed (${res.status})`));
  }

  // успех: { message: "..." }
  return payload;
}


export async function login(email: string, password: string) {
  const res = await fetch(`${API_URL}/auth/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password }),
  });

  // читаем тело ВСЕГДА, иначе на ошибке не достанешь detail
  const rawText = await res.text();

  let payload: any = null;
  try {
    payload = rawText ? JSON.parse(rawText) : null;
  } catch {
    payload = null;
  }

  if (!res.ok) {
    // FastAPI HTTPException: {"detail": "..."} или {"detail": {code,message}}
    const msg =
      payload?.detail?.message ??
      payload?.detail ??
      rawText ??
      `Login failed (${res.status})`;

    throw new Error(String(msg));
  }

  // успешный ответ (ожидаем JSON с токенами)
  const data = payload;

  localStorage.setItem('access_token', data.access_token);
  localStorage.setItem('refresh_token', data.refresh_token);

  return data;
}


export async function getMe(token: string) {
  const res = await fetch(`${API_URL}/auth/me`, {
    headers: { Authorization: `Bearer ${token}` },
  });

  if (!res.ok) throw new Error('Unauthorized');
  return res.json();
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\api\client.ts
==============================

// src/api/client.ts
import {
  Statistics,
  DifficultyRating,
  UserGroupResponse,
  Group,
  GroupCreatePayload,
} from '../types';
import { PublicDeckSummary, StudyCard, StudyMode } from '../types';
import type { ApiDeckWithCards } from '../types/api';
import type { ApiLevelIn, ApiReplaceLevelsRequest } from '../types/api';
import type { ApiCreateCardRequest, ApiCreateCardResponse } from '../types/api';


export type StudyCardsResponse = {
  cards: StudyCard[];
};

export class ApiError extends Error {
  status: number;
  detail?: string;

  constructor(status: number, message: string, detail?: string) {
    super(message);
    this.status = status;
    this.detail = detail;

    Object.setPrototypeOf(this, ApiError.prototype);
  }
}


async function refreshAccessToken(): Promise<string> {
  const refresh = localStorage.getItem('refresh_token');
  if (!refresh) throw new ApiError(401, 'No refresh token');

  const res = await fetch(`/api/auth/refresh`, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${refresh}`,
      'Content-Type': 'application/json',
    },
  });

  if (!res.ok) {
    let detail: string | undefined;
    try {
      const j = await res.json();
      detail = typeof j?.detail === 'string' ? j.detail : undefined;
    } catch {
      // ignore
    }

    // refresh протух/невалидный — чистим токены
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');

    throw new ApiError(res.status, detail || `HTTP ${res.status}`, detail);
  }

  const data = await res.json();
  const newAccess = String(data?.access_token ?? '');
  const newRefresh = String(data?.refresh_token ?? refresh);

  if (!newAccess) throw new ApiError(500, 'Refresh returned empty access_token');

  localStorage.setItem('access_token', newAccess);
  localStorage.setItem('refresh_token', newRefresh);

  return newAccess;
}

async function apiRequest<T>(path: string, init?: RequestInit): Promise<T> {
  const doFetch = async () => {
    const token = localStorage.getItem('access_token');

    return fetch(`/api${path}`, {
      ...init,
      headers: {
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
        'Content-Type': 'application/json',
        ...(init?.headers ?? {}),
      },
    });
  };

  // 1) первая попытка
  let res = await doFetch();

  // 2) если access протух — пробуем refresh ОДИН раз и повторяем запрос
  if (res.status === 401) {
    try {
      await refreshAccessToken();
      res = await doFetch();
    } catch (e) {
      throw e;
    }
  }

  if (!res.ok) {
    let detail: string | undefined;
    try {
      const j = await res.json();
      detail = typeof j?.detail === 'string' ? j.detail : undefined;
    } catch {
      // ignore
    }
    throw new ApiError(res.status, detail || `HTTP ${res.status}`, detail);
  }

  if (res.status === 204) return undefined as T;
  return (await res.json()) as T;
}

export class ApiClient {
  // ============================
  // Decks
  // ============================
  static async getUserDecks(): Promise<PublicDeckSummary[]> {
    return apiRequest<PublicDeckSummary[]>(`/decks/`);
  }

  // static async getDeckCards(deckId: string): Promise<unknown> {
  //   return apiRequest<unknown>(`/decks/${deckId}/cards`);
  // }

  static async getDeckWithCards(deckId: string): Promise<ApiDeckWithCards> {
    return apiRequest<ApiDeckWithCards>(`/decks/${deckId}/with_cards`);
  }

  // static async getDeckSession(deckId: string): Promise<unknown> {
  //   return apiRequest<unknown>(`/decks/${deckId}/session`);
  // }


  static async createDeck(payload: {
    title: string;
    description?: string | null;
    color?: string | null;
  }): Promise<PublicDeckSummary> {
    return apiRequest<PublicDeckSummary>(`/decks/`, {
      method: 'POST',
      body: JSON.stringify(payload),
    });
  }

static async updateDeck(
  deckId: string,
  payload: {
    title?: string;
    description?: string | null;
    color?: string | null;
    is_public?: boolean;
  }
): Promise<PublicDeckSummary> {
  return apiRequest<PublicDeckSummary>(`/decks/${deckId}`, {
    method: 'PATCH',
    body: JSON.stringify(payload),
  });
}


  static async deleteDeck(deckId: string): Promise<void> {
    return apiRequest<void>(`/decks/${deckId}`, { method: 'DELETE' });
  }

  static async searchPublicDecks(params: {
    q?: string;
    limit?: number;
    offset?: number;
  }): Promise<PublicDeckSummary[]> {
    const usp = new URLSearchParams();
    const q = params.q?.trim();
    if (q) usp.set('q', q);

    usp.set('limit', String(params.limit ?? 20));
    usp.set('offset', String(params.offset ?? 0));

    return apiRequest<PublicDeckSummary[]>(`/decks/public?${usp.toString()}`);
  }

  static async getStudyCards(
    deckId: string,
    params: { mode: StudyMode; limit?: number; seed?: number }
  ): Promise<StudyCardsResponse> {
    const qs = new URLSearchParams();
    qs.set('mode', params.mode);
    qs.set('include', 'full');
    if (params.limit != null) qs.set('limit', String(params.limit));
    if (params.seed != null) qs.set('seed', String(params.seed));

    return apiRequest<StudyCardsResponse>(`/decks/${deckId}/study-cards?${qs.toString()}`);
  }

  // ============================
  // Cards
  // ============================
  static async reviewCard(cardId: string, rating: DifficultyRating) {
    return apiRequest(`/cards/${cardId}/review`, {
      method: 'POST',
      body: JSON.stringify({ rating }),
    });
  }

  static async createCard(payload: ApiCreateCardRequest): Promise<ApiCreateCardResponse> {
    return apiRequest<ApiCreateCardResponse>(`/cards/`, {
      method: 'POST',
      body: JSON.stringify(payload),
    });
  }


  static async replaceCardLevels(cardId: string, levels: ApiLevelIn[]): Promise<void> {
    return apiRequest<void>(`/cards/${cardId}/levels`, {
      method: 'PUT',
      body: JSON.stringify({ levels } satisfies ApiReplaceLevelsRequest),
    });
  }

  static async levelUp(cardId: string) {
    return apiRequest(`/cards/${cardId}/level_up`, { method: 'POST' });
  }

  static async levelDown(cardId: string) {
    return apiRequest(`/cards/${cardId}/level_down`, { method: 'POST' });
  }

  static async getReviewSession(limit = 20) {
    return apiRequest(`/cards/review_with_levels?limit=${limit}`);
  }

  static async deleteCardProgress(cardId: string) {
    return apiRequest<void>(`/cards/${cardId}/progress`, { method: 'DELETE' });
  }

  static async deleteCard(cardId: string): Promise<void> {
    return apiRequest<void>(`/cards/${cardId}`, { method: 'DELETE' });
  }

  // ============================
  // Groups
  // ============================
  static async getUserGroups(): Promise<Group[]> {
    const data = await apiRequest<UserGroupResponse[]>(`/groups/`);
    return data.map((g) => ({
      id: g.user_group_id,
      title: g.title,
      description: g.description,
      parent_id: g.parent_id,
      kind: g.kind,
      source_group_id: g.source_group_id,
    }));
  }

  static async getGroupDecksSummary(groupId: string): Promise<PublicDeckSummary[]> {
    return apiRequest<PublicDeckSummary[]>(`/groups/${groupId}/decks/summary`);
  }

  static async createGroup(payload: GroupCreatePayload): Promise<Group> {
    return apiRequest<Group>(`/groups/`, {
      method: 'POST',
      body: JSON.stringify(payload),
    });
  }

  static async deleteGroup(groupId: string): Promise<void> {
    return apiRequest<void>(`/groups/${groupId}`, { method: 'DELETE' });
  }

  static async addDeckToGroup(groupId: string, deckId: string): Promise<void> {
    return apiRequest<void>(`/groups/${groupId}/decks/${deckId}`, {
      method: 'PUT',
    });
  }

  static async removeDeckFromGroup(groupId: string, deckId: string): Promise<void> {
    return apiRequest<void>(`/groups/${groupId}/decks/${deckId}`, {
      method: 'DELETE',
    });
  }

  // ============================
  // Mock / Statistics (если нужно, тоже можешь перевести на apiRequest)
  // ============================
  static async getStatistics(): Promise<Statistics> {
    return {
      cardsStudiedToday: 6,
      timeSpentToday: 15,
      currentStreak: 4,
      totalCards: 20,
      weeklyActivity: [2, 4, 3, 5, 1, 0, 50],
      achievements: [
        {
          id: 'first',
          title: 'Первый успех',
          description: 'Первое достижение',
          icon: '⭐',
          unlocked: true,
        },
        {
          id: 'ten',
          title: '10 карточек',
          description: 'Изучено 10 карточек',
          icon: '🔟',
          unlocked: true,
        },
      ],
    };
  }
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\app\AppRouter.tsx
==============================

// src/app/AppRouter.tsx
import React from 'react';

import { ResetPasswordPage } from '../screens/auth/ResetPasswordPage';
import { VerifyEmailPage } from '../screens/auth/VerifyEmailPage';

type AppRouterProps = {
  renderMain: () => React.ReactNode;
};

function getPathRoute() {
  const path = window.location.pathname || '/';
  const params = new URLSearchParams(window.location.search);
  const token = params.get('token') || '';
  return { path, token };
}

export function AppRouter(props: AppRouterProps) {
  const { path, token } = getPathRoute();

  if (path === '/reset-password') {
    return <ResetPasswordPage token={token} />;
  }

  if (path === '/verify-email') {
    return <VerifyEmailPage token={token} />;
  }

  return <>{props.renderMain()}</>;
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\app\overlays\OfflineStatus.tsx
==============================

import React, { useEffect, useState } from 'react';

export function OfflineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  if (isOnline) return null;

  return (
    <div className="offline-status">
      <div className="offline-status__inner">
        <div className="pulse-dot" />
        <span style={{ color: '#FF9A76' }}>Работаем в офлайн-режиме</span>
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\app\overlays\PWAUpdatePrompt.tsx
==============================

import React, { useEffect, useState } from 'react';

// Компонент для отображения обновлений PWA
export function PWAUpdatePrompt() {
  const [showReload, setShowReload] = useState(false);
  const [waitingWorker, setWaitingWorker] = useState<ServiceWorker | null>(null);

  useEffect(() => {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.ready.then((registration) => {
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                setShowReload(true);
                setWaitingWorker(newWorker);
              }
            });
          }
        });
      });

      let refreshing = false;
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (!refreshing) {
          refreshing = true;
          window.location.reload();
        }
      });
    }
  }, []);

  const reloadPage = () => {
    waitingWorker?.postMessage({ type: 'SKIP_WAITING' });
    setShowReload(false);
    window.location.reload();
  };

  if (!showReload) return null;

  return (
    <div className="update-prompt">
      <div className="update-prompt__inner">
        <div className="update-prompt__row">
          <div className="update-prompt__icon">🔄</div>
          <div>
            <p style={{ color: '#E8EAF0', fontWeight: 500 }}>Доступно обновление!</p>
            <p style={{ color: '#9CA3AF', fontSize: '0.875rem', marginTop: '0.25rem' }}>
              Новая версия приложения загружена. Обновите для получения новых функций.
            </p>
          </div>
          <div className="update-prompt__actions">
            <button onClick={() => setShowReload(false)} className="btn-ghost">
              Позже
            </button>
            <button onClick={reloadPage} className="btn-primary">
              Обновить
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\app\pwa\useIsPWA.ts
==============================

import { useEffect, useState } from 'react';

export function useIsPWA() {
  const [isPWA, setIsPWA] = useState(false);

  useEffect(() => {
    const checkPWA = () => {
      if (
        window.matchMedia('(display-mode: standalone)').matches ||
        (window.navigator as any).standalone ||
        document.referrer.includes('android-app://')
      ) {
        setIsPWA(true);
      }
    };

    checkPWA();
  }, []);

  return isPWA;
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\app\pwa\useRegisterServiceWorker.ts
==============================

import { useEffect } from 'react';

export function useRegisterServiceWorker() {
  useEffect(() => {
    if (!('serviceWorker' in navigator)) return;
    if (process.env.NODE_ENV !== 'production') return;

    const onLoad = () => {
      navigator.serviceWorker.register('/sw.js');
    };

    window.addEventListener('load', onLoad);
    return () => window.removeEventListener('load', onLoad);
  }, []);
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\auth\AuthContext.tsx
==============================

import React, { createContext, useContext, useState, useEffect } from 'react';

interface User {
  id: string;
  email: string;
  username: string;
}

interface AuthContextType {
  token: string | null;
  refreshToken: string | null;
  currentUser: User | null;
  login: (accessToken: string, refreshToken: string) => Promise<void>;
  logout: () => void;
  refreshAccessToken: () => Promise<string | null>;
}

const AuthContext = createContext<AuthContextType | null>(null);

const API_URL = '/api';

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [token, setToken] = useState<string | null>(localStorage.getItem('access_token'));
  const [refreshToken, setRefreshToken] = useState<string | null>(localStorage.getItem('refresh_token'));
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  const fetchMe = async (jwtToken: string) => {
    const res = await fetch(`${API_URL}/auth/me`, {
      headers: { Authorization: `Bearer ${jwtToken}` },
    });

    if (res.status === 401 || res.status === 403) {
      throw new Error('unauthorized');
    }

    if (!res.ok) {
      throw new Error('temporary_error');
    }

    const user: User = await res.json();
    setCurrentUser(user);
  };

  // Обновить access token через refresh
  const refreshAccessToken = async (): Promise<string | null> => {
    if (!refreshToken) {
      logout();
      return null;
    }

    try {
      const res = await fetch(`${API_URL}/auth/refresh`, {
        method: 'POST',
        headers: { Authorization: `Bearer ${refreshToken}` },
      });

      if (!res.ok) {
        logout();
        return null;
      }

      const data = await res.json();
      const newAccessToken = data.access_token;
      localStorage.setItem('access_token', newAccessToken);
      setToken(newAccessToken);
      return newAccessToken;
    } catch (err) {
      logout();
      return null;
    }
  };

  // Логин с access + refresh токенами
  const login = async (accessToken: string, newRefreshToken: string) => {
    localStorage.setItem('access_token', accessToken);
    localStorage.setItem('refresh_token', newRefreshToken);
    setToken(accessToken);
    setRefreshToken(newRefreshToken);
    await fetchMe(accessToken);
  };

  // Логаут
  const logout = () => {
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');
    setToken(null);
    setRefreshToken(null);
    setCurrentUser(null);
  };

  // Подтягиваем пользователя при старте, если access token есть
  useEffect(() => {
    if (!token) {
      setLoading(false);
      return;
    }

    fetchMe(token)
      .catch((err) => {
        if (err.message === 'unauthorized') logout();
        console.error('fetchMe error:', err);
      })
      .finally(() => setLoading(false));
  }, [token]);

  return (
    <AuthContext.Provider value={{ token, refreshToken, currentUser, login, logout, refreshAccessToken }}>
      {!loading ? children : <div className="min-h-screen center-vertical"><p>Загрузка...</p></div>}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error('useAuth must be used inside AuthProvider');
  return ctx;
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\auth\AuthGate.tsx
==============================

// src/auth/AuthGate.tsx
import React from 'react';
import { useAuth } from './AuthContext';
import { Login } from '../screens/auth/Login';
import { Register } from '../screens/auth/Register';

export function AuthGate({ children }: { children: React.ReactNode }) {
  const { token, currentUser } = useAuth();
  const [mode, setMode] = React.useState<'login' | 'register'>('login');

  if (!token || !currentUser) {
    return mode === 'login' ? (
      <Login onSwitch={() => setMode('register')} />
    ) : (
      <Register onSwitch={() => setMode('login')} />
    );
  }

  return <>{children}</>;
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\BottomNav.tsx
==============================

import React from 'react';
import { Home, BookOpen, BarChart3, User } from 'lucide-react';

interface BottomNavProps {
  activeTab: 'home' | 'study' | 'stats' | 'profile';
  onTabChange: (tab: 'home' | 'study' | 'stats' | 'profile') => void;
}

export function BottomNav({ activeTab, onTabChange }: BottomNavProps) {
  const tabs = [
    { id: 'home' as const, icon: Home, label: 'Главная' },
    { id: 'study' as const, icon: BookOpen, label: 'Обучение' },
    { id: 'stats' as const, icon: BarChart3, label: 'Статистика' },
    { id: 'profile' as const, icon: User, label: 'Профиль' },
  ];
  
  return (
    <nav className="bottom-nav">
      <div className="bottom-nav__inner">
        {tabs.map(({ id, icon: Icon, label }) => (
          <button
            key={id}
            onClick={() => onTabChange(id)}
            className={`bottom-nav__item ${activeTab === id ? 'bottom-nav__item--active' : ''}`}
          >
            <Icon size={24} strokeWidth={2} />
            <span className="bottom-nav__label">{label}</span>
          </button>
        ))}
      </div>
    </nav>
  );
}



==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\DeckCard.tsx
==============================

import React from 'react';
import { PublicDeckSummary } from '../types';
import { ProgressBar } from './ProgressBar';
import { ChevronRight } from 'lucide-react';
import { useAuth } from '../auth/AuthContext';
import './DeckCard.css';

interface DeckCardProps {
  deck: PublicDeckSummary;
  onClick: () => void;
  onEdit?: () => void;
}

export function DeckCard({ deck, onClick, onEdit }: DeckCardProps) {
  const { currentUser } = useAuth();
  const isOwner = currentUser?.id === deck.owner_id;
  const description = deck.description?.trim();

  const totalCards = deck.cards_count;
  const completedCards = deck.completed_cards_count;
  const repetitionsCount = deck.count_repeat;
  const forRepetition = deck.count_for_repeat;
  const progress = totalCards > 0 ? Math.round((completedCards / totalCards) * 100) : 0;

  return (
    <button onClick={onClick} className="deck-card">
      <h3 className="deck-card__title">{deck.title}</h3>
      
      <div className="deck-card__description-box">
        {description ? (
          <p className="deck-card__description">{description}</p>
        ) : (
          <p className="deck-card__description">Описание отсутствует</p>
        )}
      </div>

      <div className="deck-card__stats">
        <span className="deck-card__stat">Прогресс: {progress}%</span>
        <span className="deck-card__stat">Количество повторений: {repetitionsCount}</span>
        <span className="deck-card__stat">Для повторения: {forRepetition}</span>
      </div>

      <div className="deck-card__progress-container">
        <div className="deck-card__progress-bar">
          <div 
            className="deck-card__progress-fill" 
            style={{ width: `${progress}%` }}
          />
          <span className="deck-card__progress-text">
            {completedCards} / {totalCards}
          </span>
        </div>
      </div>
    </button>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\FlipCard.tsx
==============================

import React from 'react';
import { StudyCard } from '../types';
import { motion } from 'motion/react';
import { MarkdownView } from './MarkdownView';

interface FlipCardProps {
  card: StudyCard;
  isFlipped: boolean;
  onFlip: () => void;

  onLevelUp?: () => void;
  onLevelDown?: () => void;

  // NEW:
  frontContent?: React.ReactNode;
  backContent?: React.ReactNode;
  disableFlipOnClick?: boolean;
}

function getLevelIndex(l: any): number {
  return typeof l?.level_index === 'number' ? l.level_index : l?.levelindex;
}

export function FlipCard({
  card,
  isFlipped,
  onFlip,
  onLevelUp,
  onLevelDown,
  frontContent,
  backContent,
  disableFlipOnClick = false,
}: FlipCardProps) {
  const level =
    card.levels.find((l: any) => getLevelIndex(l) === card.activeLevel) ?? card.levels[0];

  const frontText = (level as any)?.content?.question || (card as any).title || '…';
  const backText = (level as any)?.content?.answer || '…';

  const hasPrev = card.levels.some((l: any) => getLevelIndex(l) === card.activeLevel - 1);
  const hasNext = card.levels.some((l: any) => getLevelIndex(l) === card.activeLevel + 1);

  const canDown = hasPrev;
  const canUp = hasNext;

  const handleClick = () => {
    if (disableFlipOnClick) return;
    onFlip();
  };

  return (
    <div className="flipcard-container">
      <motion.div className="flipcard" onClick={handleClick} style={{ perspective: 1000 }}>
        <motion.div
          className="flipcard__inner"
          initial={false}
          animate={{ transform: isFlipped ? 'rotateY(180deg)' : 'rotateY(0deg)' }}
          transition={{ duration: 0.6, ease: 'easeInOut' }}
        >
          {/* Front */}
          <div className="flipcard__side flipcard__front">
            <div className="flipcard__text">
              {frontContent ?? <MarkdownView value={frontText} />}
            </div>
            <div className="flipcard__hint">Нажмите, чтобы увидеть ответ</div>
          </div>

          {/* Back */}
          <div className="flipcard__side flipcard__back">
            {(canDown || canUp) && (
              <div className="flipcard__level-controls" onClick={(e) => e.stopPropagation()}>
                {canDown ? (
                  <button
                    type="button"
                    className="flipcard__level-btn flipcard__level-btn--left"
                    onClick={(e) => {
                      e.stopPropagation();
                      onLevelDown?.();
                    }}
                  >
                    &lt; проще
                  </button>
                ) : (
                  <div />
                )}

                {canUp ? (
                  <button
                    type="button"
                    className="flipcard__level-btn flipcard__level-btn--right"
                    onClick={(e) => {
                      e.stopPropagation();
                      onLevelUp?.();
                    }}
                  >
                    сложнее &gt;
                  </button>
                ) : (
                  <div />
                )}
              </div>
            )}

            <div className="flipcard__text">
              {backContent ?? <MarkdownView value={backText} />}
            </div>

            <div className="flipcard__hint">
              Уровень {card.activeLevel + 1} из {card.levels.length}
            </div>
          </div>
        </motion.div>
      </motion.div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\Input.tsx
==============================

import React from 'react';

type InputType =
  | 'text'
  | 'password'
  | 'email'
  | 'number'
  | 'search'
  | 'tel'
  | 'url';

interface InputProps {
  value: string;
  onChange: (value: string) => void;

  type?: InputType;          // <-- добавили
  placeholder?: string;
  label?: string;

  multiline?: boolean;
  rows?: number;
  disabled?: boolean;
}

export function Input({
  value,
  onChange,
  type = 'text',             // <-- дефолт
  placeholder,
  label,
  multiline = false,
  rows = 3,
  disabled = false,
}: InputProps) {
  return (
    <div className="form-row">
      {label && <label className="form-label">{label}</label>}

      {multiline ? (
        <textarea
          value={value}
          onChange={(e) => onChange(e.target.value)}
          placeholder={placeholder}
          rows={rows}
          disabled={disabled}
          className="input input--textarea"
        />
      ) : (
        <input
          type={type}          // <-- пробросили сюда
          value={value}
          onChange={(e) => onChange(e.target.value)}
          placeholder={placeholder}
          disabled={disabled}
          className="input"
        />
      )}
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\InstallPrompt.tsx
==============================

import React, { useState, useEffect } from 'react';
import { Download, X } from 'lucide-react';
import { motion, AnimatePresence } from 'motion/react';

export function InstallPrompt() {
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null);
  const [showPrompt, setShowPrompt] = useState(false);

  useEffect(() => {
    const handler = (e: Event) => {
      // Предотвращаем стандартный браузерный промпт
      e.preventDefault();
      // Сохраняем событие для использования позже
      setDeferredPrompt(e);
      // Показываем наш кастомный промпт
      setShowPrompt(true);
    };

    window.addEventListener('beforeinstallprompt', handler);

    return () => {
      window.removeEventListener('beforeinstallprompt', handler);
    };
  }, []);

  const handleInstall = async () => {
    if (!deferredPrompt) {
      return;
    }

    // Показываем промпт установки
    deferredPrompt.prompt();

    // Ждем выбора пользователя
    const { outcome } = await deferredPrompt.userChoice;
    
    console.log(`User response: ${outcome}`);

    // Очищаем сохраненный промпт
    setDeferredPrompt(null);
    setShowPrompt(false);
  };

  const handleDismiss = () => {
    setShowPrompt(false);
  };

  return (
    <AnimatePresence>
      {showPrompt && (
        <motion.div initial={{ y: 100, opacity: 0 }} animate={{ y: 0, opacity: 1 }} exit={{ y: 100, opacity: 0 }} className="install-prompt">
          <div className="install-prompt__card">
            <div className="install-prompt__row">
              <div className="install-prompt__icon">
                <Download size={24} className="text-white" />
              </div>

              <div style={{ flex: 1 }}>
                <h3 style={{ color: '#E8EAF0', marginBottom: '0.25rem' }}>Установить приложение</h3>
                <p style={{ color: '#9CA3AF', marginBottom: '0.5rem' }}>
                  Добавьте MenmonicFlow на главный экран для быстрого доступа
                </p>

                <div className="install-prompt__actions">
                  <button onClick={handleInstall} className="btn-primary small">Установить</button>
                  <button onClick={handleDismiss} className="btn-ghost small">Позже</button>
                </div>
              </div>

              <button onClick={handleDismiss} style={{ background: 'transparent', border: 0, color: '#9CA3AF' }}>
                <X size={20} />
              </button>
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}



==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\LevelIndicator.tsx
==============================

import React from 'react';

interface LevelIndicatorProps {
  currentLevel: 0 | 1 | 2 | 3;
  size?: 'small' | 'medium' | 'large';
}

export function LevelIndicator({ currentLevel, size = 'medium' }: LevelIndicatorProps) {
  const sizeClass = `level-indicator--${size}`;

  return (
    <div className={`level-indicator ${sizeClass}`} aria-hidden>
      {[0, 1, 2, 3].map((level) => (
        <div
          key={level}
          className={`level-indicator__dot ${level <= currentLevel ? 'level-indicator__dot--active' : ''}`}
        />
      ))}
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\MarkdownField.tsx
==============================

import React from 'react';
import MDEditor from '@uiw/react-md-editor';
import { Eye, EyeOff } from 'lucide-react';
import { MarkdownView } from './MarkdownView';

type Props = {
  label: string;
  value: string;
  onChange: (next: string) => void;

  preview: boolean;
  onTogglePreview: () => void;

  disabled?: boolean;
  emptyPreviewText?: string;
  className?: string;
};

export function MarkdownField({
  label,
  value,
  onChange,
  preview,
  onTogglePreview,
  disabled = false,
  emptyPreviewText = '*Пусто*',
  className,
}: Props) {
  return (
    <div className={className}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
        <label className="form-label" style={{ marginBottom: 0 }}>
          {label}
        </label>

        <button
          type="button"
          onClick={onTogglePreview}
          className="icon-btn icon-btn--raise"
          aria-label={preview ? 'Выключить предпросмотр' : 'Включить предпросмотр'}
          title={preview ? 'Выключить предпросмотр' : 'Включить предпросмотр'}
          disabled={disabled}
        >
          {preview ? <EyeOff size={24} /> : <Eye size={24} />}
        </button>
      </div>

      {!preview ? (
        <MDEditor
          value={value}
          onChange={(v) => onChange(v ?? '')}
          preview="edit"
          extraCommands={[]}
          visibleDragbar={false}
        />
      ) : (
        <MarkdownView value={value.trim() ? value : emptyPreviewText} />
      )}
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\MarkdownView.tsx
==============================

// src/components/MarkdownView.tsx
import React from 'react';
import ReactMarkdown from 'react-markdown';
import remarkMath from 'remark-math';
import remarkGfm from 'remark-gfm';
import rehypeKatex from 'rehype-katex';
import 'katex/dist/katex.min.css';

import { convertBracketLatexToDollar } from '../utils/latexDelimiters';

export function MarkdownView({ value }: { value: string }) {
  const processed = convertBracketLatexToDollar(value ?? '');

  return (
    <ReactMarkdown
      remarkPlugins={[remarkMath, remarkGfm]}
      rehypePlugins={[rehypeKatex]}
    >
      {processed}
    </ReactMarkdown>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ProgressBar.tsx
==============================

import React from 'react';

interface ProgressBarProps {
  progress: number; // 0-100
  color?: string;
  height?: string;
}

export function ProgressBar({ progress, color = '#4A6FA5', height = '8px' }: ProgressBarProps) {
  return (
    <div className="w-full bg-gray-200 rounded-full overflow-hidden" style={{ height }}>
      <div
        className="h-full transition-all duration-300 ease-out rounded-full"
        style={{
          width: `${Math.min(100, Math.max(0, progress))}%`,
          backgroundColor: color,
        }}
      />
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\RatingButton.tsx
==============================

import React from 'react';
import { DifficultyRating } from '../types';

interface RatingButtonProps {
  rating: DifficultyRating;
  label: string;
  onClick: () => void;
}

export function RatingButton({ rating, label, onClick }: RatingButtonProps) {
  const colors = {
    again: { bg: '#E53E3E', active: '#c53030' },
    hard: { bg: '#F6AD55', active: '#ed8936' },
    good: { bg: '#4A6FA5', active: '#3a5a8a' },
    easy: { bg: '#38A169', active: '#2f855a' },
  };
  
  return (
    <button
      onClick={onClick}
      data-rating={rating}
      style={{ background: colors[rating].bg }}
      className={`rating-button rating-button--circle text-white transition-all duration-200 shadow-md`}
    >
      <span className="text-xs">{label}</span>
    </button>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ResumeSession.tsx
==============================

import React from 'react';
import './ResumeSession.css';

interface ResumeSessionCardProps {
  title: string;
  subtitle: string;
  cardInfo: string;
  onResume: () => void;
  onDiscard: () => void;
}

export function ResumeSessionCard({ 
  title, 
  subtitle, 
  cardInfo, 
  onResume, 
  onDiscard 
}: ResumeSessionCardProps) {
  return (
    <div className="resume-session">
      <div className="resume-session__card">
        <h3 className="resume-session__title">{title}</h3>
        <p className="resume-session__subtitle">{subtitle}</p>
        <p className="resume-session__info">{cardInfo}</p>
        
        <div className="resume-session__buttons">
          <button 
            className="resume-session__button resume-session__button--primary" 
            onClick={onResume}
          >
            Продолжить
          </button>
          <button 
            className="resume-session__button resume-session__button--secondary" 
            onClick={onDiscard}
          >
            Сбросить
          </button>
        </div>
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\Button\Button.tsx
==============================

import React from 'react';
// @ts-ignore: CSS module without type declarations
import styles from './Button.module.css';
import { cn } from '../ui/utils';

type ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {
  variant?: 'primary' | 'secondary';
  size?: 'small' | 'medium' | 'large';
  fullWidth?: boolean;
};

export function Button({
  children,
  variant = 'primary',
  size = 'medium',
  fullWidth = false,
  className = '',
  type = 'button',
  ...rest
}: ButtonProps) {
  const variantClass = variant === 'primary' ? 'btn--primary' : 'btn--secondary';
  const sizeClass = size === 'small' ? 'btn--small' : size === 'large' ? 'btn--large' : 'btn--medium';
  const fullClass = fullWidth ? 'btn--full' : '';

  const classes = cn(styles.button, variantClass, sizeClass, fullClass, className);

  return (
    <button className={classes} type={type} {...rest}>
      {children}
    </button>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\figma\ImageWithFallback.tsx
==============================

import React, { useState } from 'react'

const ERROR_IMG_SRC =
  'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODgiIGhlaWdodD0iODgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBvcGFjaXR5PSIuMyIgZmlsbD0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIzLjciPjxyZWN0IHg9IjE2IiB5PSIxNiIgd2lkdGg9IjU2IiBoZWlnaHQ9IjU2IiByeD0iNiIvPjxwYXRoIGQ9Im0xNiA1OCAxNi0xOCAzMiAzMiIvPjxjaXJjbGUgY3g9IjUzIiBjeT0iMzUiIHI9IjciLz48L3N2Zz4KCg=='

export function ImageWithFallback(props: React.ImgHTMLAttributes<HTMLImageElement>) {
  const [didError, setDidError] = useState(false)

  const handleError = () => {
    setDidError(true)
  }

  const { src, alt, style, className, ...rest } = props

  return didError ? (
    <div className={`image-fallback ${className ?? ''}`} style={style}>
      <div className="image-fallback__inner">
        <img src={ERROR_IMG_SRC} alt="Error loading image" {...rest} data-original-url={src} />
      </div>
    </div>
  ) : (
    <img src={src} alt={alt} className={className} style={style} {...rest} onError={handleError} />
  )
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\accordion.tsx
==============================

"use client";

import * as React from "react";
import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { ChevronDownIcon } from "lucide-react";

import { cn } from "./utils";

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />;
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("accordion__item", className)}
      {...props}
    />
  );
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn("accordion__trigger", className)}
        {...props}
      >
        {children}
        <ChevronDownIcon className={cn("icon icon--sm accordion__chevron")} />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  );
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="accordion__content"
      {...props}
    >
      <div className={cn("accordion__inner", className)}>{children}</div>
    </AccordionPrimitive.Content>
  );
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\alert-dialog.tsx
==============================

"use client";

import * as React from "react";
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";

import { cn } from "./utils";
import { buttonVariants } from "./button";

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />;
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  );
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  );
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn("alert-dialog__overlay", className)}
      {...props}
    />
  );
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn("alert-dialog__content", className)}
        {...props}
      />
    </AlertDialogPortal>
  );
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("alert-dialog__header", className)}
      {...props}
    />
  );
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn("alert-dialog__footer", className)}
      {...props}
    />
  );
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  );
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  );
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  );
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\alert.tsx
==============================

import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "./utils";

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid grid-cols-[0_1fr] gap-y-0.5 items-start svg--sm alert--with-icon",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive: "text-destructive bg-card alert--destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  );
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className,
      )}
      {...props}
    />
  );
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm alert__description",
        className,
      )}
      {...props}
    />
  );
}

export { Alert, AlertTitle, AlertDescription };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\aspect-ratio.tsx
==============================

"use client";

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio";

function AspectRatio({
  ...props
}: React.ComponentProps<typeof AspectRatioPrimitive.Root>) {
  return <AspectRatioPrimitive.Root data-slot="aspect-ratio" {...props} />;
}

export { AspectRatio };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\avatar.tsx
==============================

"use client";

import * as React from "react";
import * as AvatarPrimitive from "@radix-ui/react-avatar";

import { cn } from "./utils";

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn("avatar", className)}
      {...props}
    />
  );
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("avatar__image", className)}
      {...props}
    />
  );
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn("avatar__fallback", className)}
      {...props}
    />
  );
}

export { Avatar, AvatarImage, AvatarFallback };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\badge.tsx
==============================

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";

import { cn } from "./utils";

type BadgeVariant = "default" | "secondary" | "destructive" | "outline";

function badgeVariants(opts?: { variant?: BadgeVariant; extra?: string }) {
  const variant = opts?.variant || "default";
  return cn("badge", `badge--${variant}`, opts?.extra);
}

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> & { variant?: BadgeVariant; asChild?: boolean }) {
  const Comp = asChild ? Slot : "span";

  return <Comp data-slot="badge" className={badgeVariants({ variant, extra: className })} {...props} />;
}

export { Badge, badgeVariants };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\breadcrumb.tsx
==============================

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { ChevronRight, MoreHorizontal } from "lucide-react";

import { cn } from "./utils";

function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />;
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn("breadcrumb__list", className)}
      {...props}
    />
  );
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn("inline-flex items-center gap-1.5", className)}
      {...props}
    />
  );
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean;
}) {
  const Comp = asChild ? Slot : "a";

  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn("hover:text-foreground transition-colors", className)}
      {...props}
    />
  );
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  );
}

function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("svg--xs", className)}
      {...props}
    >
      {children ?? <ChevronRight className="icon icon--xs" />}
    </li>
  );
}

function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span data-slot="breadcrumb-ellipsis" role="presentation" aria-hidden="true" className={cn("breadcrumb__ellipsis", className)} {...props}>
      <MoreHorizontal className="icon icon--sm" />
      <span className="sr-only">More</span>
    </span>
  );
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\button.tsx
==============================

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";

import { cn } from "./utils";

type Variant = "default" | "destructive" | "outline" | "secondary" | "ghost" | "link";
type Size = "default" | "sm" | "lg" | "icon";

function buttonVariants(opts?: { variant?: Variant; size?: Size; extra?: string }) {
  const variant = opts?.variant || "default";
  const size = opts?.size || "default";
  const sizeMap: Record<Size, string> = {
    default: "btn--medium",
    sm: "btn--small",
    lg: "btn--large",
    icon: "btn--icon",
  };

  return cn("btn", `btn--${variant}`, sizeMap[size], opts?.extra);
}

function Button({
  className,
  variant = "default",
  size = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & {
  variant?: Variant;
  size?: Size;
  asChild?: boolean;
}) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp data-slot="button" className={buttonVariants({ variant, size, extra: className })} {...props} />
  );
}

export { Button, buttonVariants };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\calendar.tsx
==============================

"use client";

import * as React from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { DayPicker } from "react-day-picker";

import { cn } from "./utils";
import { buttonVariants } from "./button";

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: React.ComponentProps<typeof DayPicker>) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
    months: "calendar__months",
        month: "flex flex-col gap-4",
        caption: "flex justify-center pt-1 relative items-center w-full",
        caption_label: "text-sm font-medium",
        nav: "flex items-center gap-1",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "calendar__nav-button",
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-x-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "calendar__cell relative p-0 text-center text-sm focus-within:relative focus-within:z-20",
          props.mode === "range" ? "calendar__cell--range" : "calendar__cell--single",
        ),
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "calendar__day p-0 font-normal",
        ),
        day_range_start:
          "day-range-start aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_range_end:
          "day-range-end aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: (p: any) => (
          <ChevronLeft className={cn("icon icon--sm", p.className)} {...p} />
        ),
        IconRight: (p: any) => (
          <ChevronRight className={cn("icon icon--sm", p.className)} {...p} />
        ),
      }}
      {...props}
    />
  );
}

export { Calendar };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\card.tsx
==============================

import * as React from "react";

import { cn } from "./utils";

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn("card", className)}
      {...props}
    />
  );
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn("card__header", className)}
      {...props}
    />
  );
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <h4
      data-slot="card-title"
      className={cn("card__title", className)}
      {...props}
    />
  );
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <p
      data-slot="card-description"
      className={cn("card__description", className)}
      {...props}
    />
  );
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn("card__action", className)}
      {...props}
    />
  );
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("card__content", className)}
      {...props}
    />
  );
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("card__footer", className)}
      {...props}
    />
  );
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\carousel.tsx
==============================

"use client";

import * as React from "react";
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react";
import { ArrowLeft, ArrowRight } from "lucide-react";

import { cn } from "./utils";
import { Button } from "./button";

type CarouselApi = UseEmblaCarouselType[1];
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>;
type CarouselOptions = UseCarouselParameters[0];
type CarouselPlugin = UseCarouselParameters[1];

type CarouselProps = {
  opts?: CarouselOptions;
  plugins?: CarouselPlugin;
  orientation?: "horizontal" | "vertical";
  setApi?: (api: CarouselApi) => void;
};

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0];
  api: ReturnType<typeof useEmblaCarousel>[1];
  scrollPrev: () => void;
  scrollNext: () => void;
  canScrollPrev: boolean;
  canScrollNext: boolean;
} & CarouselProps;

const CarouselContext = React.createContext<CarouselContextProps | null>(null);

function useCarousel() {
  const context = React.useContext(CarouselContext);

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />");
  }

  return context;
}

function Carousel({
  orientation = "horizontal",
  opts,
  setApi,
  plugins,
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & CarouselProps) {
  const [carouselRef, api] = useEmblaCarousel(
    {
      ...opts,
      axis: orientation === "horizontal" ? "x" : "y",
    },
    plugins,
  );
  const [canScrollPrev, setCanScrollPrev] = React.useState(false);
  const [canScrollNext, setCanScrollNext] = React.useState(false);

  const onSelect = React.useCallback((api: CarouselApi) => {
    if (!api) return;
    setCanScrollPrev(api.canScrollPrev());
    setCanScrollNext(api.canScrollNext());
  }, []);

  const scrollPrev = React.useCallback(() => {
    api?.scrollPrev();
  }, [api]);

  const scrollNext = React.useCallback(() => {
    api?.scrollNext();
  }, [api]);

  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (event.key === "ArrowLeft") {
        event.preventDefault();
        scrollPrev();
      } else if (event.key === "ArrowRight") {
        event.preventDefault();
        scrollNext();
      }
    },
    [scrollPrev, scrollNext],
  );

  React.useEffect(() => {
    if (!api || !setApi) return;
    setApi(api);
  }, [api, setApi]);

  React.useEffect(() => {
    if (!api) return;
    onSelect(api);
    api.on("reInit", onSelect);
    api.on("select", onSelect);

    return () => {
      api?.off("select", onSelect);
    };
  }, [api, onSelect]);

  return (
    <CarouselContext.Provider
      value={{
        carouselRef,
        api: api,
        opts,
        orientation:
          orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
        scrollPrev,
        scrollNext,
        canScrollPrev,
        canScrollNext,
      }}
    >
      <div
        onKeyDownCapture={handleKeyDown}
        className={cn("carousel", className)}
        role="region"
        aria-roledescription="carousel"
        data-slot="carousel"
        {...props}
      >
        {children}
      </div>
    </CarouselContext.Provider>
  );
}

function CarouselContent({ className, ...props }: React.ComponentProps<"div">) {
  const { carouselRef, orientation } = useCarousel();

  return (
    <div ref={carouselRef} className="carousel__overflow" data-slot="carousel-content">
      <div
        className={cn(
          "carousel__track",
          orientation === "horizontal" ? "carousel__track--horizontal" : "carousel__track--vertical",
          className,
        )}
        {...props}
      />
    </div>
  );
}

function CarouselItem({ className, ...props }: React.ComponentProps<"div">) {
  const { orientation } = useCarousel();

  return (
    <div
      role="group"
      aria-roledescription="slide"
      data-slot="carousel-item"
      className={cn(
        "carousel__item",
        orientation === "horizontal" ? "carousel__item--horizontal" : "carousel__item--vertical",
        className,
      )}
      {...props}
    />
  );
}

function CarouselPrevious({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel();

  return (
    <Button
      data-slot="carousel-previous"
      variant={variant}
      size={size}
      className={cn(
        "carousel__nav carousel__nav--prev",
        orientation === "horizontal" ? "carousel__nav--horizontal" : "carousel__nav--vertical",
        className,
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="icon" />
      <span className="sr-only">Previous slide</span>
    </Button>
  );
}

function CarouselNext({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollNext, canScrollNext } = useCarousel();

  return (
    <Button
      data-slot="carousel-next"
      variant={variant}
      size={size}
      className={cn(
        "carousel__nav carousel__nav--next",
        orientation === "horizontal" ? "carousel__nav--horizontal" : "carousel__nav--vertical",
        className,
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="icon" />
      <span className="sr-only">Next slide</span>
    </Button>
  );
}

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\chart.tsx
==============================

"use client";

import * as React from "react";
import * as RechartsPrimitive from "recharts";

import { cn } from "./utils";

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const;

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode;
    icon?: React.ComponentType;
  } & (
                    <div
                      className={cn("chart__indicator", {
                        "chart__indicator--dot": indicator === "dot",
                        "chart__indicator--line": indicator === "line",
                        "chart__indicator--dashed": indicator === "dashed",
                        "chart__indicator--dashed-nest": nestLabel && indicator === "dashed",
                      })}
                      style={{
                        ["--color-bg" as any]: indicatorColor,
                        ["--color-border" as any]: indicatorColor,
                      } as React.CSSProperties}
                    />
  return context;
}

function ChartContainer({
  id,
  className,
  children,
  config,
  ...props
}: React.ComponentProps<"div"> & {
  config: ChartConfig;
  children: React.ComponentProps<
    typeof RechartsPrimitive.ResponsiveContainer
  >["children"];
}) {
  const uniqueId = React.useId();
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`;

  return (
    <ChartContext.Provider value={{ config }}>
      <div data-slot="chart" data-chart={chartId} className={cn("chart__container", className)} {...props}>
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  );
}

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color,
  );

  if (!colorConfig.length) {
    return null;
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color;
    return color ? `  --color-${key}: ${color};` : null;
  })
  .join("\n")}
}
`,
          )
          .join("\n"),
      }}
    />
  );
};

const ChartTooltip = RechartsPrimitive.Tooltip;

function ChartTooltipContent({
  active,
  payload,
  className,
  indicator = "dot",
  hideLabel = false,
  hideIndicator = false,
  label,
  labelFormatter,
  labelClassName,
  formatter,
  color,
  nameKey,
  labelKey,
}: React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
  React.ComponentProps<"div"> & {
    hideLabel?: boolean;
    hideIndicator?: boolean;
    indicator?: "line" | "dot" | "dashed";
    nameKey?: string;
    labelKey?: string;
  }) {
  const { config } = useChart();

  const tooltipLabel = React.useMemo(() => {
    if (hideLabel || !payload?.length) {
      return null;
    }

    const [item] = payload;
    const key = `${labelKey || item?.dataKey || item?.name || "value"}`;
    const itemConfig = getPayloadConfigFromPayload(config, item, key);
    const value =
      !labelKey && typeof label === "string"
        ? config[label as keyof typeof config]?.label || label
        : itemConfig?.label;

    if (labelFormatter) {
      return (
        <div className={cn("font-medium", labelClassName)}>
          {labelFormatter(value, payload)}
        </div>
      );
    }

    if (!value) {
      return null;
    }

    return <div className={cn("font-medium", labelClassName)}>{value}</div>;
  }, [
    label,
    labelFormatter,
    payload,
    hideLabel,
    labelClassName,
    config,
    labelKey,
  ]);

  if (!active || !payload?.length) {
    return null;
  }

  const nestLabel = payload.length === 1 && indicator !== "dot";

  return (
    <div
      className={cn("chart__tooltip", className)}
    >
      {!nestLabel ? tooltipLabel : null}
      <div className="grid gap-1.5">
        {payload.map((item, index) => {
          const key = `${nameKey || item.name || item.dataKey || "value"}`;
          const itemConfig = getPayloadConfigFromPayload(config, item, key);
          const indicatorColor = color || item.payload.fill || item.color;

          return (
            <div
              key={item.dataKey}
              className={cn(
                "chart__row flex w-full flex-wrap items-stretch gap-2",
                indicator === "dot" && "items-center",
              )}
            >
              {formatter && item?.value !== undefined && item.name ? (
                formatter(item.value, item.name, item, index, item.payload)
              ) : (
                <>
                  {itemConfig?.icon ? (
                    <itemConfig.icon />
                  ) : (
                    !hideIndicator && (() => {
                      const indicatorClass = ["chart__indicator"]
                        .concat(indicator === "dot" ? ["chart__indicator--dot"] : [])
                        .concat(indicator === "line" ? ["chart__indicator--line"] : [])
                        .concat(indicator === "dashed" ? ["chart__indicator--dashed"] : [])
                        .concat(nestLabel && indicator === "dashed" ? ["chart__indicator--dashed-nest"] : [])
                        .join(" ");

                      return (
                        <div
                          className={indicatorClass}
                          style={{
                            // Use CSS variables for colors
                            ["--color-bg" as any]: indicatorColor,
                            ["--color-border" as any]: indicatorColor,
                          } as React.CSSProperties}
                        />
                      );
                    })()
                  )}
                  <div
                    className={cn(
                      "flex flex-1 justify-between leading-none",
                      nestLabel ? "items-end" : "items-center",
                    )}
                  >
                    <div className="grid gap-1.5">
                      {nestLabel ? tooltipLabel : null}
                      <span className="text-muted-foreground">
                        {itemConfig?.label || item.name}
                      </span>
                    </div>
                    {item.value && (
                      <span className="text-foreground font-mono font-medium tabular-nums">
                        {item.value.toLocaleString()}
                      </span>
                    )}
                  </div>
                </>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
}

const ChartLegend = RechartsPrimitive.Legend;

function ChartLegendContent({
  className,
  hideIcon = false,
  payload,
  verticalAlign = "bottom",
  nameKey,
}: React.ComponentProps<"div"> &
  Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
    hideIcon?: boolean;
    nameKey?: string;
  }) {
  const { config } = useChart();

  if (!payload?.length) {
    return null;
  }

  return (
    <div
      className={cn(
        "flex items-center justify-center gap-4",
        verticalAlign === "top" ? "pb-3" : "pt-3",
        className,
      )}
    >
      {payload.map((item) => {
        const key = `${nameKey || item.dataKey || "value"}`;
        const itemConfig = getPayloadConfigFromPayload(config, item, key);

        return (
          <div
            key={item.value}
            className={cn("chart__legend-item flex items-center gap-1.5")}
          >
            {itemConfig?.icon && !hideIcon ? (
              <itemConfig.icon />
            ) : (
              <div
                className="h-2 w-2 shrink-0 rounded-[2px]"
                style={{
                  backgroundColor: item.color,
                }}
              />
            )}
            {itemConfig?.label}
          </div>
        );
      })}
    </div>
  );
}

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string,
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined;
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined;

  let configLabelKey: string = key;

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string;
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string;
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config];
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\checkbox.tsx
==============================

"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { CheckIcon } from "lucide-react";

import { cn } from "./utils";

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn("checkbox", className)}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="checkbox__indicator"
      >
        <CheckIcon className="checkbox__icon" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  );
}

export { Checkbox };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\collapsible.tsx
==============================

"use client";

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible";

function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />;
}

function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  );
}

function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  );
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\command.tsx
==============================

"use client";

import * as React from "react";
import { Command as CommandPrimitive } from "cmdk";
import { SearchIcon } from "lucide-react";

import { cn } from "./utils";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "./dialog";

function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn("command", className)}
      {...props}
    />
  );
}

function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  className,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string;
  description?: string;
  className?: string;
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent className="dialog__content--no-pad">
        <Command className={cn("command", className)}>
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className={cn("command__input-wrapper", className)}
    >
      <SearchIcon className="icon icon--sm icon--muted" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "command__input",
          className,
        )}
        {...props}
      />
    </div>
  );
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "command__list",
        className,
      )}
      {...props}
    />
  );
}

function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="command__empty"
      {...props}
    />
  );
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn("command__group", className)}
      {...props}
    />
  );
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("command__separator", className)}
      {...props}
    />
  );
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "command__item",
        className,
      )}
      {...props}
    />
  );
}

function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn("command__shortcut", className)}
      {...props}
    />
  );
}

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\context-menu.tsx
==============================

"use client";

import * as React from "react";
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu";
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";

import { cn } from "./utils";

function ContextMenu({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />;
}

function ContextMenuTrigger({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return (
    <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />
  );
}

function ContextMenuGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return (
    <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />
  );
}

function ContextMenuPortal({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return (
    <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />
  );
}

function ContextMenuSub({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />;
}

function ContextMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return (
    <ContextMenuPrimitive.RadioGroup
      data-slot="context-menu-radio-group"
      {...props}
    />
  );
}

function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn("context-menu__sub-trigger", className)}
      {...props}
    >
      {children}
      <ChevronRightIcon className="context-menu__chevron" />
    </ContextMenuPrimitive.SubTrigger>
  );
}

function ContextMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
        className={cn("context-menu__sub-content", className)}
      {...props}
    />
  );
}

function ContextMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn("context-menu__content", className)}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  );
}

function ContextMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn("context-menu__item", className)}
      {...props}
    />
  );
}

function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn("context-menu__checkbox-item", className)}
      checked={checked}
      {...props}
    >
      <span className="context-menu__item-indicator">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="icon icon--sm" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  );
}

function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn("context-menu__radio-item", className)}
      {...props}
    >
      <span className="context-menu__item-indicator">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="icon icon--xs context-menu__radio-icon" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  );
}

function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn("context-menu__label", className)}
      {...props}
    />
  );
}

function ContextMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn("context-menu__separator", className)}
      {...props}
    />
  );
}

function ContextMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span data-slot="context-menu-shortcut" className={cn("context-menu__shortcut", className)} {...props} />
  );
}

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\dialog.tsx
==============================

"use client";

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { XIcon } from "lucide-react";

import { cn } from "./utils";

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />;
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />;
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />;
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />;
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn("dialog__overlay", className)}
      {...props}
    />
  );
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn("dialog__content", className)}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className={cn("dialog__close")}>
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  );
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div data-slot="dialog-header" className={cn("dialog__header", className)} {...props} />
  );
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div data-slot="dialog-footer" className={cn("dialog__footer", className)} {...props} />
  );
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title data-slot="dialog-title" className={cn("dialog__title", className)} {...props} />
  );
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description data-slot="dialog-description" className={cn("dialog__description", className)} {...props} />
  );
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\drawer.tsx
==============================

"use client";

import * as React from "react";
import { Drawer as DrawerPrimitive } from "vaul";

import { cn } from "./utils";

function Drawer({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) {
  return <DrawerPrimitive.Root data-slot="drawer" {...props} />;
}

function DrawerTrigger({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Trigger>) {
  return <DrawerPrimitive.Trigger data-slot="drawer-trigger" {...props} />;
}

function DrawerPortal({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Portal>) {
  return <DrawerPrimitive.Portal data-slot="drawer-portal" {...props} />;
}

function DrawerClose({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Close>) {
  return <DrawerPrimitive.Close data-slot="drawer-close" {...props} />;
}

function DrawerOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Overlay>) {
  return (
    <DrawerPrimitive.Overlay
      data-slot="drawer-overlay"
      className={cn("drawer__overlay", className)}
      {...props}
    />
  );
}

function DrawerContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Content>) {
  return (
    <DrawerPortal data-slot="drawer-portal">
      <DrawerOverlay />
      <DrawerPrimitive.Content
        data-slot="drawer-content"
        className={cn("drawer__content", className)}
        {...props}
      >
        <div className="drawer__drag-handle" />
        {children}
      </DrawerPrimitive.Content>
    </DrawerPortal>
  );
}

function DrawerHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-header"
      className={cn("drawer__header", className)}
      {...props}
    />
  );
}

function DrawerFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-footer"
      className={cn("drawer__footer", className)}
      {...props}
    />
  );
}

function DrawerTitle({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Title>) {
  return (
    <DrawerPrimitive.Title
      data-slot="drawer-title"
      className={cn("drawer__title", className)}
      {...props}
    />
  );
}

function DrawerDescription({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Description>) {
  return (
    <DrawerPrimitive.Description
      data-slot="drawer-description"
      className={cn("drawer__description", className)}
      {...props}
    />
  );
}

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\dropdown-menu.tsx
==============================

"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";

import { cn } from "./utils";

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />;
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  );
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  );
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
      <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn("dropdown__content", className)}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  );
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  );
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn("dropdown__item", className)}
      {...props}
    />
  );
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn("dropdown__checkbox-item", className)}
      checked={checked}
      {...props}
    >
      <span className="dropdown__item-indicator">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="icon icon--sm" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  );
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  );
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn("dropdown__radio-item", className)}
      {...props}
    >
      <span className="dropdown__item-indicator">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="icon icon--sm dropdown__radio-icon" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  );
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn("dropdown__label", className)}
      {...props}
    />
  );
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("dropdown__separator", className)}
      {...props}
    />
  );
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn("dropdown__shortcut", className)}
      {...props}
    />
  );
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />;
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn("dropdown__sub-trigger", className)}
      {...props}
    >
      {children}
  <ChevronRightIcon className="icon icon--sm dropdown__chevron" />
    </DropdownMenuPrimitive.SubTrigger>
  );
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn("dropdown__sub-content", className)}
      {...props}
    />
  );
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\form.tsx
==============================

"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { Slot } from "@radix-ui/react-slot";
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form";

import { cn } from "./utils";
import { Label } from "./label";

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState } = useFormContext();
  const formState = useFormState({ name: fieldContext.name });
  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div data-slot="form-item" className={cn("form__item", className)} {...props} />
    </FormItemContext.Provider>
  );
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField();

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("form__label", className)}
      htmlFor={formItemId}
      {...props}
    />
  );
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField();

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("form__description", className)}
      {...props}
    />
  );
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message ?? "") : props.children;

  if (!body) {
    return null;
  }

  return (
    <p data-slot="form-message" id={formMessageId} className={cn("form__message", className)} {...props}>
      {body}
    </p>
  );
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\hover-card.tsx
==============================

"use client";

import * as React from "react";
import * as HoverCardPrimitive from "@radix-ui/react-hover-card";

import { cn } from "./utils";

function HoverCard({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Root>) {
  return <HoverCardPrimitive.Root data-slot="hover-card" {...props} />;
}

function HoverCardTrigger({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Trigger>) {
  return (
    <HoverCardPrimitive.Trigger data-slot="hover-card-trigger" {...props} />
  );
}

function HoverCardContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Content>) {
  return (
    <HoverCardPrimitive.Portal data-slot="hover-card-portal">
      <HoverCardPrimitive.Content
        data-slot="hover-card-content"
        align={align}
        sideOffset={sideOffset}
        className={cn("hovercard__content", className)}
        {...props}
      />
    </HoverCardPrimitive.Portal>
  );
}

export { HoverCard, HoverCardTrigger, HoverCardContent };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\input-otp.tsx
==============================

"use client";

import * as React from "react";
import { OTPInput, OTPInputContext } from "input-otp";
import { MinusIcon } from "lucide-react";

import { cn } from "./utils";

function InputOTP({
  className,
  containerClassName,
  ...props
}: React.ComponentProps<typeof OTPInput> & {
  containerClassName?: string;
}) {
  return (
    <OTPInput
      data-slot="input-otp"
      containerClassName={cn(
        "flex items-center gap-2 has-disabled:opacity-50",
        containerClassName,
      )}
      className={cn("disabled:cursor-not-allowed", className)}
      {...props}
    />
  );
}

function InputOTPGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="input-otp-group"
      className={cn("flex items-center gap-1", className)}
      {...props}
    />
  );
}

function InputOTPSlot({
  index,
  className,
  ...props
}: React.ComponentProps<"div"> & {
  index: number;
}) {
  const inputOTPContext = React.useContext(OTPInputContext);
  const { char, hasFakeCaret, isActive } = inputOTPContext?.slots[index] ?? {};

  return (
    <div
      data-slot="input-otp-slot"
      data-active={isActive}
      className={cn("input-otp__slot", className)}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink bg-foreground h-4 w-px duration-1000" />
        </div>
      )}
    </div>
  );
}

function InputOTPSeparator({ ...props }: React.ComponentProps<"div">) {
  return (
    <div data-slot="input-otp-separator" role="separator" {...props}>
      <MinusIcon />
    </div>
  );
}

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\input.tsx
==============================

import * as React from "react";

import { cn } from "./utils";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn("input", className)}
      {...props}
    />
  );
}

export { Input };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\label.tsx
==============================

"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";

import { cn } from "./utils";

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn("label", className)}
      {...props}
    />
  );
}

export { Label };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\menubar.tsx
==============================

"use client";

import * as React from "react";
import * as MenubarPrimitive from "@radix-ui/react-menubar";
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";

import { cn } from "./utils";

function Menubar({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Root>) {
  return (
    <MenubarPrimitive.Root
      data-slot="menubar"
      className={cn("menubar", className)}
      {...props}
    />
  );
}

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu data-slot="menubar-menu" {...props} />;
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group data-slot="menubar-group" {...props} />;
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal data-slot="menubar-portal" {...props} />;
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return (
    <MenubarPrimitive.RadioGroup data-slot="menubar-radio-group" {...props} />
  );
}

function MenubarTrigger({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Trigger>) {
  return (
    <MenubarPrimitive.Trigger
      data-slot="menubar-trigger"
      className={cn("menubar__trigger", className)}
      {...props}
    />
  );
}

function MenubarContent({
  className,
  align = "start",
  alignOffset = -4,
  sideOffset = 8,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Content>) {
  return (
    <MenubarPortal>
      <MenubarPrimitive.Content
        data-slot="menubar-content"
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn("menubar__content", className)}
        {...props}
      />
    </MenubarPortal>
  );
}

function MenubarItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
}) {
  return (
    <MenubarPrimitive.Item
      data-slot="menubar-item"
      data-inset={inset}
      data-variant={variant}
      className={cn("menubar__item", className)}
      {...props}
    />
  );
}

function MenubarCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.CheckboxItem>) {
  return (
    <MenubarPrimitive.CheckboxItem
      data-slot="menubar-checkbox-item"
      className={cn("menubar__item menubar__checkbox-item", className)}
      checked={checked}
      {...props}
    >
        <span className="menubar__item-indicator">
        <MenubarPrimitive.ItemIndicator>
          <CheckIcon className="icon icon--sm" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.CheckboxItem>
  );
}

function MenubarRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioItem>) {
  return (
    <MenubarPrimitive.RadioItem
      data-slot="menubar-radio-item"
      className={cn("menubar__item menubar__radio-item", className)}
      {...props}
    >
        <span className="menubar__item-indicator">
        <MenubarPrimitive.ItemIndicator>
          <CircleIcon className="icon icon--xs menubar__radio-icon" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.RadioItem>
  );
}

function MenubarLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <MenubarPrimitive.Label
      data-slot="menubar-label"
      data-inset={inset}
      className={cn("menubar__label", className)}
      {...props}
    />
  );
}

function MenubarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Separator>) {
  return (
    <MenubarPrimitive.Separator
      data-slot="menubar-separator"
      className={cn("menubar__separator", className)}
      {...props}
    />
  );
}

function MenubarShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="menubar-shortcut"
      className={cn("menubar__shortcut", className)}
      {...props}
    />
  );
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />;
}

function MenubarSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <MenubarPrimitive.SubTrigger
      data-slot="menubar-sub-trigger"
      data-inset={inset}
      className={cn("menubar__sub-trigger", className)}
      {...props}
    >
      {children}
      <ChevronRightIcon className="menubar__chevron" />
    </MenubarPrimitive.SubTrigger>
  );
}

function MenubarSubContent({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubContent>) {
  return (
    <MenubarPrimitive.SubContent
      data-slot="menubar-sub-content"
      className={cn("menubar__sub-content", className)}
      {...props}
    />
  );
}

export {
  Menubar,
  MenubarPortal,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarGroup,
  MenubarSeparator,
  MenubarLabel,
  MenubarItem,
  MenubarShortcut,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSub,
  MenubarSubTrigger,
  MenubarSubContent,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\navigation-menu.tsx
==============================

import * as React from "react";
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu";
import { cva } from "class-variance-authority";
import { ChevronDownIcon } from "lucide-react";

import { cn } from "./utils";

function NavigationMenu({
  className,
  children,
  viewport = true,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Root> & {
  viewport?: boolean;
}) {
  return (
    <NavigationMenuPrimitive.Root
      data-slot="navigation-menu"
      data-viewport={viewport}
      className={cn("navigation-menu", className)}
      {...props}
    >
      {children}
      {viewport && <NavigationMenuViewport />}
    </NavigationMenuPrimitive.Root>
  );
}

function NavigationMenuList({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.List>) {
  return (
    <NavigationMenuPrimitive.List
      data-slot="navigation-menu-list"
      className={cn("navigation-menu__list", className)}
      {...props}
    />
  );
}

function NavigationMenuItem({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Item>) {
  return (
    <NavigationMenuPrimitive.Item
      data-slot="navigation-menu-item"
      className={cn("relative", className)}
      {...props}
    />
  );
}

const navigationMenuTriggerStyle = cva(
  "navigation__trigger",
);

function NavigationMenuTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Trigger>) {
  return (
      <NavigationMenuPrimitive.Trigger
        data-slot="navigation-menu-trigger"
        className={cn(navigationMenuTriggerStyle(), className)}
        {...props}
      >
        {children}{" "}
        <ChevronDownIcon
          className={cn("icon icon--sm navigation__chevron navigation__chevron--offset")}
          aria-hidden="true"
        />
      </NavigationMenuPrimitive.Trigger>
  );
}

function NavigationMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Content>) {
  return (
    <NavigationMenuPrimitive.Content
      data-slot="navigation-menu-content"
      className={cn("navigation-menu__content", className)}
      {...props}
    />
  );
}

function NavigationMenuViewport({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Viewport>) {
  return (
    <div className={cn("navigation-menu__viewport-container")}>
      <NavigationMenuPrimitive.Viewport
        data-slot="navigation-menu-viewport"
        className={cn("navigation-menu__viewport", className)}
        {...props}
      />
    </div>
  );
}

function NavigationMenuLink({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Link>) {
  return (
    <NavigationMenuPrimitive.Link
      data-slot="navigation-menu-link"
      className={cn("navigation__link", className)}
      {...props}
    />
  );
}

function NavigationMenuIndicator({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Indicator>) {
  return (
    <NavigationMenuPrimitive.Indicator
      data-slot="navigation-menu-indicator"
      className={cn("navigation-menu__indicator", className)}
      {...props}
    >
      <div className="navigation-menu__indicator-dot" />
    </NavigationMenuPrimitive.Indicator>
  );
}

export {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
  navigationMenuTriggerStyle,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\pagination.tsx
==============================

import * as React from "react";
import {
  ChevronLeftIcon,
  ChevronRightIcon,
  MoreHorizontalIcon,
} from "lucide-react";

import { cn } from "./utils";
import { Button, buttonVariants } from "./button";

function Pagination({ className, ...props }: React.ComponentProps<"nav">) {
  return (
    <nav
      role="navigation"
      aria-label="pagination"
      data-slot="pagination"
      className={cn("mx-auto flex w-full justify-center", className)}
      {...props}
    />
  );
}

function PaginationContent({
  className,
  ...props
}: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="pagination-content"
      className={cn("flex flex-row items-center gap-1", className)}
      {...props}
    />
  );
}

function PaginationItem({ ...props }: React.ComponentProps<"li">) {
  return <li data-slot="pagination-item" {...props} />;
}

type PaginationLinkProps = {
  isActive?: boolean;
} & Pick<React.ComponentProps<typeof Button>, "size"> &
  React.ComponentProps<"a">;

function PaginationLink({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) {
  return (
    <a
      aria-current={isActive ? "page" : undefined}
      data-slot="pagination-link"
      data-active={isActive}
      className={cn(
        buttonVariants({
          variant: isActive ? "outline" : "ghost",
          size,
        }),
        className,
      )}
      {...props}
    />
  );
}

function PaginationPrevious({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to previous page"
      size="default"
      className={cn("pagination__prev", className)}
      {...props}
    >
      <ChevronLeftIcon />
      <span className="pagination__label">Previous</span>
    </PaginationLink>
  );
}

function PaginationNext({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to next page"
      size="default"
      className={cn("pagination__next", className)}
      {...props}
    >
      <span className="pagination__label">Next</span>
      <ChevronRightIcon />
    </PaginationLink>
  );
}

function PaginationEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span aria-hidden data-slot="pagination-ellipsis" className={cn("pagination__ellipsis", className)} {...props}>
      <MoreHorizontalIcon className="icon icon--sm" />
      <span className="sr-only">More pages</span>
    </span>
  );
}

export {
  Pagination,
  PaginationContent,
  PaginationLink,
  PaginationItem,
  PaginationPrevious,
  PaginationNext,
  PaginationEllipsis,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\popover.tsx
==============================

"use client";

import * as React from "react";
import * as PopoverPrimitive from "@radix-ui/react-popover";

import { cn } from "./utils";

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />;
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />;
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn("popover__content", className)}
        {...props}
      />
    </PopoverPrimitive.Portal>
  );
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />;
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\progress.tsx
==============================

"use client";

import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";

import { cn } from "./utils";

function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn("progress", className)}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className={cn("progress__fill")}
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  );
}

export { Progress };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\radio-group.tsx
==============================

"use client";

import * as React from "react";
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { CircleIcon } from "lucide-react";

import { cn } from "./utils";

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("radio-group", className)}
      {...props}
    />
  );
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn("radio-group__item", className)}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="radio-group__indicator"
      >
        <CircleIcon className="radio-group__dot" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
}

export { RadioGroup, RadioGroupItem };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\resizable.tsx
==============================

"use client";

import * as React from "react";
import { GripVerticalIcon } from "lucide-react";
import * as ResizablePrimitive from "react-resizable-panels";

import { cn } from "./utils";

function ResizablePanelGroup({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) {
  return (
    <ResizablePrimitive.PanelGroup
      data-slot="resizable-panel-group"
      className={cn("resizable-panel-group", className)}
      {...props}
    />
  );
}

function ResizablePanel({
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.Panel>) {
  return <ResizablePrimitive.Panel data-slot="resizable-panel" {...props} />;
}

function ResizableHandle({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean;
}) {
  return (
    <ResizablePrimitive.PanelResizeHandle
      data-slot="resizable-handle"
      className={cn("resizable-handle", className)}
      {...props}
    >
      {withHandle && (
          <div className="bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border">
          <GripVerticalIcon className="icon icon--xs" />
        </div>
      )}
    </ResizablePrimitive.PanelResizeHandle>
  );
}

export { ResizablePanelGroup, ResizablePanel, ResizableHandle };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\scroll-area.tsx
==============================

"use client";

import * as React from "react";
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";

import { cn } from "./utils";

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport data-slot="scroll-area-viewport" className="scroll-area__viewport" >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  );
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className,
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  );
}

export { ScrollArea, ScrollBar };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\select.tsx
==============================

"use client";

import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import {
  CheckIcon,
  ChevronDownIcon,
  ChevronUpIcon,
} from "lucide-react";

import { cn } from "./utils";

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />;
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />;
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />;
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default";
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn("select__trigger", className)}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="icon icon--sm icon--muted" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  );
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "select__content",
          position === "popper" && "select__content--popper",
          className,
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "select__viewport",
            position === "popper" && "select__viewport--popper",
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  );
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("select__label", className)}
      {...props}
    />
  );
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn("select__item", className)}
      {...props}
    >
      <span className="select__item-indicator">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="icon icon--sm" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  );
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("select__separator", className)}
      {...props}
    />
  );
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
      <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn("select__scroll-button", className)}
      {...props}
    >
      <ChevronUpIcon className="icon icon--sm" />
    </SelectPrimitive.ScrollUpButton>
  );
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
      <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn("select__scroll-button", className)}
      {...props}
    >
      <ChevronDownIcon className="icon icon--sm" />
    </SelectPrimitive.ScrollDownButton>
  );
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\separator.tsx
==============================

"use client";

import * as React from "react";
import * as SeparatorPrimitive from "@radix-ui/react-separator";

import { cn } from "./utils";

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn("separator", className)}
      {...props}
    />
  );
}

export { Separator };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\sheet.tsx
==============================

"use client";

import * as React from "react";
import * as SheetPrimitive from "@radix-ui/react-dialog";
import { XIcon } from "lucide-react";

import { cn } from "./utils";

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />;
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />;
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />;
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />;
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn("sheet__overlay", className)}
      {...props}
    />
  );
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left";
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "sheet",
          side === "right" && "sheet__panel sheet__panel--right",
          side === "left" && "sheet__panel sheet__panel--left",
          side === "top" && "sheet__panel sheet__panel--top",
          side === "bottom" && "sheet__panel sheet__panel--bottom",
          className,
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="sheet__close">
          <XIcon className="icon icon--sm" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  );
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  );
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  );
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  );
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\sidebar.tsx
==============================

"use client";

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { useIsMobile } from "./use-mobile";
import { cn } from "./utils";

type SidebarContextProps = {
  open: boolean;
  setOpen: (v: boolean) => void;
  isMobile: boolean;
  openMobile: boolean;
  setOpenMobile: (v: boolean) => void;
};

const SidebarContext = React.createContext<SidebarContextProps | null>(null);

function SidebarProvider({ children, defaultOpen = true }: { children: React.ReactNode; defaultOpen?: boolean }) {
  const [open, setOpen] = React.useState<boolean>(defaultOpen);
  const [openMobile, setOpenMobile] = React.useState<boolean>(false);
  const isMobile = useIsMobile();

  return (
    <SidebarContext.Provider value={{ open, setOpen, isMobile, openMobile, setOpenMobile }}>
      {children}
    </SidebarContext.Provider>
  );
}

function useSidebar() {
  const ctx = React.useContext(SidebarContext);
  if (!ctx) {
    return {
      open: true,
      setOpen: () => {},
      isMobile: false,
      openMobile: false,
      setOpenMobile: () => {},
    };
  }
  return ctx;
}

function Sidebar({ className, ...props }: React.ComponentProps<"aside">) {
  return <aside data-slot="sidebar" className={cn("sidebar", className)} {...props} />;
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="sidebar-header" className={cn("sidebar__header", className)} {...props} />;
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="sidebar-content" className={cn("sidebar__content", className)} {...props} />;
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="sidebar-footer" className={cn("sidebar__footer", className)} {...props} />;
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="sidebar-group" className={cn("sidebar__group", className)} {...props} />;
}

function SidebarGroupLabel({ className, asChild = false, ...props }: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div";
  return <Comp data-slot="sidebar-group-label" className={cn("sidebar__group-label", className)} {...props} />;
}

function SidebarGroupAction({ className, asChild = false, ...props }: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button";
  return <Comp data-slot="sidebar-group-action" className={cn("sidebar__group-action", className)} {...props} />;
}

function SidebarGroupContent({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="sidebar-group-content" className={cn("sidebar__group-content", className)} {...props} />;
}

function SidebarRail({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="sidebar-rail" className={cn("sidebar__rail", className)} {...props} />;
}

function SidebarSeparator({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="sidebar-separator" className={cn("sidebar__separator", className)} {...props} />;
}

function SidebarInput({ className, ...props }: React.ComponentProps<"input">) {
  return <input data-slot="sidebar-input" className={cn("sidebar__input", className)} {...props} />;
}

function SidebarInset({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="sidebar-inset" className={cn("sidebar__inset", className)} {...props} />;
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return <ul data-slot="sidebar-menu" className={cn("sidebar__menu", className)} {...props} />;
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return <li data-slot="sidebar-menu-item" className={cn("sidebar__menu-item", className)} {...props} />;
}

function SidebarMenuButton({ className, ...props }: React.ComponentProps<"button">) {
  return <button data-slot="sidebar-menu-button" className={cn("sidebar__menu-button", className)} {...props} />;
}

function SidebarMenuAction({ className, ...props }: React.ComponentProps<"button">) {
  return <button data-slot="sidebar-menu-action" className={cn("sidebar__menu-action", className)} {...props} />;
}

function SidebarMenuBadge({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="sidebar-menu-badge" className={cn("sidebar__menu-badge", className)} {...props} />;
}

function SidebarMenuSkeleton({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="sidebar-menu-skeleton" className={cn("sidebar__menu-skeleton", className)} {...props} />;
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return <ul data-slot="sidebar-menu-sub" className={cn("sidebar__menu-sub", className)} {...props} />;
}

function SidebarMenuSubItem({ className, ...props }: React.ComponentProps<"li">) {
  return <li data-slot="sidebar-menu-sub-item" className={cn("sidebar__menu-sub-item", className)} {...props} />;
}

function SidebarMenuSubButton({ className, ...props }: React.ComponentProps<"a">) {
  return <a data-slot="sidebar-menu-sub-button" className={cn("sidebar__menu-sub-button", className)} {...props} />;
}

function SidebarTrigger({ className, ...props }: React.ComponentProps<"button">) {
  return <button data-slot="sidebar-trigger" className={cn("sidebar__trigger", className)} {...props} />;
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\skeleton.tsx
==============================

import { cn } from "./utils";

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  );
}

export { Skeleton };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\slider.tsx
==============================

"use client";

import * as React from "react";
import * as SliderPrimitive from "@radix-ui/react-slider";

import { cn } from "./utils";

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max],
  );

  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        "slider",
        className,
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={cn(
          "slider__track",
        )}
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={cn(
            "slider__range",
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="slider__thumb"
        />
      ))}
    </SliderPrimitive.Root>
  );
}

export { Slider };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\sonner.tsx
==============================

"use client";

import { useTheme } from "next-themes";
import { Toaster as Sonner, ToasterProps } from "sonner";

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  );
};

export { Toaster };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\switch.tsx
==============================

"use client";

import * as React from "react";
import * as SwitchPrimitive from "@radix-ui/react-switch";

import { cn } from "./utils";

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn("switch", className)}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn("switch__thumb")}
      />
    </SwitchPrimitive.Root>
  );
}

export { Switch };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\table.tsx
==============================

"use client";

import * as React from "react";

import { cn } from "./utils";

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="table__container"
    >
      <table
        data-slot="table"
        className={cn("table", className)}
        {...props}
      />
    </div>
  );
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("table__header", className)}
      {...props}
    />
  );
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("table__body", className)}
      {...props}
    />
  );
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn("table__footer", className)}
      {...props}
    />
  );
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn("table__row", className)}
      {...props}
    />
  );
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn("table__head", className)}
      {...props}
    />
  );
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn("table__cell", className)}
      {...props}
    />
  );
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("table__caption", className)}
      {...props}
    />
  );
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\tabs.tsx
==============================

"use client";

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";

import { cn } from "./utils";

function Tabs({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root data-slot="tabs" className={cn("flex flex-col gap-2", className)} {...props} />
  );
}

function TabsList({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn("bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-xl p-[3px] flex", className)}
      {...props}
    />
  );
}

function TabsTrigger({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn("tabs__trigger", className)}
      {...props}
    />
  );
}

function TabsContent({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return <TabsPrimitive.Content data-slot="tabs-content" className={cn("flex-1 outline-none", className)} {...props} />;
}

export { Tabs, TabsList, TabsTrigger, TabsContent };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\textarea.tsx
==============================

import * as React from "react";

import { cn } from "./utils";

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn("textarea", className)}
      {...props}
    />
  );
}

export { Textarea };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\toggle-group.tsx
==============================

"use client";

import * as React from "react";
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group";
import { type VariantProps } from "class-variance-authority";

import { cn } from "./utils";
import { toggleVariants } from "./toggle";

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
});

function ToggleGroup({
  className,
  variant,
  size,
  children,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <ToggleGroupPrimitive.Root
      data-slot="toggle-group"
      data-variant={variant}
      data-size={size}
      className={cn("toggle-group", className)}
      {...props}
    >
      <ToggleGroupContext.Provider value={{ variant, size }}>
        {children}
      </ToggleGroupContext.Provider>
    </ToggleGroupPrimitive.Root>
  );
}

function ToggleGroupItem({
  className,
  children,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Item> &
  VariantProps<typeof toggleVariants>) {
  const context = React.useContext(ToggleGroupContext);

  return (
    <ToggleGroupPrimitive.Item
      data-slot="toggle-group-item"
      data-variant={context.variant || variant}
      data-size={context.size || size}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        "toggle-group__item",
        className,
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  );
}

export { ToggleGroup, ToggleGroupItem };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\toggle.tsx
==============================

"use client";

import * as React from "react";
import * as TogglePrimitive from "@radix-ui/react-toggle";

import { cn } from "./utils";

type ToggleVariant = "default" | "outline";
type ToggleSize = "default" | "sm" | "lg";

function toggleVariants(opts?: { variant?: ToggleVariant; size?: ToggleSize; extra?: string }) {
  const variant = opts?.variant || "default";
  const size = opts?.size || "default";
  const sizeMap: Record<ToggleSize, string> = {
    default: "toggle--medium",
    sm: "toggle--small",
    lg: "toggle--large",
  };

  return cn("toggle", `toggle--${variant}`, sizeMap[size], opts?.extra);
}

function Toggle({
  className,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof TogglePrimitive.Root> & { variant?: ToggleVariant; size?: ToggleSize }) {
  return <TogglePrimitive.Root data-slot="toggle" className={toggleVariants({ variant, size, extra: className })} {...props} />;
}

export { Toggle, toggleVariants };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\tooltip.tsx
==============================

"use client";

import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "./utils";

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  );
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  );
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />;
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn("tooltip__content", className)}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className={cn("tooltip__arrow")} />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  );
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\use-mobile.ts
==============================

import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined,
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\components\ui\utils.ts
==============================

import { clsx, type ClassValue } from "clsx";

export function cn(...inputs: ClassValue[]) {
  return clsx(inputs);
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\hooks\index.ts
==============================

export { useApiData, useCards, useStatistics } from './useApi';
export { useStudySession } from './useStudySession';



==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\hooks\useApi.ts
==============================

import { useState, useEffect, useCallback } from 'react';
import { ApiClient } from '../api/client';
import { Statistics } from '../types';

export function useApiData<T>() {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async (fetchFn: () => Promise<T>) => {
    try {
      setLoading(true);
      setError(null);
      const result = await fetchFn();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      console.error('API Error:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  return { data, loading, error, fetchData };
}

export function useCards(deckId?: string) {
  const { data, loading, error, fetchData } = useApiData<Card[]>();

  const fetchCards = useCallback(async () => {
    const cards = await ApiClient.getCards(deckId);
    return cards.map(parseDatesInCard);
  }, [deckId]);

  useEffect(() => {
    fetchData(fetchCards);
  }, [deckId, fetchData, fetchCards]);

  const refresh = useCallback((): Promise<void> => {
    return fetchData(fetchCards);
  }, [fetchData, fetchCards]);

  return { cards: data || [], loading, error, refresh };
}


// export function useDecks() {
//   const { data, loading, error, fetchData } = useApiData<Deck[]>();

//   useEffect(() => {
//     fetchData(() => ApiClient.getDecks());
//   }, [fetchData]);

//   const refresh = useCallback(() => {
//     fetchData(() => ApiClient.getDecks());
//   }, [fetchData]);

//   return { decks: data || [], loading, error, refresh };
// }

export function useStatistics() {
  const { data, loading, error, fetchData } = useApiData<Statistics>();

  useEffect(() => {
    fetchData(() => ApiClient.getStatistics());
  }, [fetchData]);

  const refresh = useCallback((): Promise<void> => {
    return fetchData(() => ApiClient.getStatistics());
  }, [fetchData]);

  return { statistics: data, loading, error, refresh };
}


const parseDatesInCard = (card: any): Card => ({
  ...card,
  nextReview: new Date(card.nextReview),
  lastReviewed: card.lastReviewed ? new Date(card.lastReviewed) : undefined,
});





==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\hooks\useDecks.ts
==============================

import { useState, useEffect, useCallback } from 'react';
import type { PublicDeckSummary } from '../types';
import { ApiClient, ApiError } from '../api/client';

export type UseDecksResult = {
  decks: PublicDeckSummary[];
  loading: boolean;
  error: string | null;
  refresh: () => Promise<void>;
};

export default function useDecks(groupId: string | null): UseDecksResult {
  const [decks, setDecks] = useState<PublicDeckSummary[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const refresh = useCallback(async () => {
    if (!groupId) return;

    setLoading(true);
    setError(null);

    try {
      const data = await ApiClient.getGroupDecksSummary(groupId);
      setDecks(data);
    } catch (e: unknown) {
      if (e instanceof ApiError) setError(e.detail ?? e.message);
      else setError('Не удалось загрузить колоды');
    } finally {
      setLoading(false);
    }
  }, [groupId]);

  useEffect(() => {
    if (!groupId) {
      setDecks([]);
      setError(null);
      setLoading(false);
      return;
    }
    refresh();
  }, [groupId, refresh]);

  return { decks, loading, error, refresh };
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\hooks\useGroupsDecksController.ts
==============================

// src/hooks/useGroupsDecksController.ts
import { useCallback, useEffect, useMemo, useState } from 'react';
import type { Dispatch, SetStateAction } from 'react';

import useDecks from './useDecks';
import { ApiClient } from '../api/client';
import type { Group } from '../types';

type UseDecksReturn = ReturnType<typeof useDecks>;

export type GroupsDecksController = {
  groups: Group[];
  activeGroupId: string | null;
  setActiveGroupId: Dispatch<SetStateAction<string | null>>;

  decks: UseDecksReturn['decks'];
  decksLoading: UseDecksReturn['loading'];
  decksError: UseDecksReturn['error'];
  refreshDecks: UseDecksReturn['refresh'];

  refreshGroups: () => Promise<void>;
  deleteActiveGroup: () => Promise<void>;

  currentGroupDeckIds: string[];
};

export function useGroupsDecksController(): GroupsDecksController {
  const [activeGroupId, setActiveGroupId] = useState<string | null>(() => {
    const v = localStorage.getItem('active_group_id');
    if (!v || v === 'null' || v === 'undefined' || v.trim() === '') return null;
    return v;
  });

  const [groups, setGroups] = useState<Group[]>([]);

  const refreshGroups = useCallback(async (): Promise<void> => {
    const gs = await ApiClient.getUserGroups();
    setGroups(gs);

    setActiveGroupId((prev) => {
      if (prev && gs.some((g) => g.id === prev)) return prev;

      const stored = localStorage.getItem('active_group_id');
      if (stored && gs.some((g) => g.id === stored)) return stored;

      return gs[0]?.id ?? null;
    });
  }, []);

  useEffect(() => {
    refreshGroups().catch(console.error);
  }, [refreshGroups]);

  useEffect(() => {
    if (activeGroupId) localStorage.setItem('active_group_id', activeGroupId);
    else localStorage.removeItem('active_group_id');
  }, [activeGroupId]);

  const { decks, loading: decksLoading, error: decksError, refresh: refreshDecks } =
    useDecks(activeGroupId);

  const currentGroupDeckIds = useMemo(() => decks.map((d: any) => d.deck_id), [decks]);

  const deleteActiveGroup = useCallback(async (): Promise<void> => {
    if (!activeGroupId) return;

    const g = groups.find((x) => x.id === activeGroupId);
    const ok = window.confirm(
      `Удалить группу "${g?.title ?? 'без названия'}"? Это действие нельзя отменить.`
    );
    if (!ok) return;

    try {
      await ApiClient.deleteGroup(activeGroupId);
      await refreshGroups();
    } catch (e) {
      console.error(e);
      alert('Не удалось удалить группу');
    }
  }, [activeGroupId, groups, refreshGroups]);

  return {
    groups,
    activeGroupId,
    setActiveGroupId,

    decks,
    decksLoading,
    decksError,
    refreshDecks,

    refreshGroups,
    deleteActiveGroup,

    currentGroupDeckIds,
  };
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\hooks\useStudySession.ts
==============================

// src/hooks/useStudySession.ts
import { useState, useEffect, useMemo, useRef } from 'react';
import { StudyCard, DifficultyRating } from '../types';
import { ApiClient } from '../api/client';

const clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(max, v));

export function useStudySession(deckCards: StudyCard[] | null, initialIndex = 0) {
  const [cards, setCards] = useState<StudyCard[]>([]);
  const [currentIndex, setCurrentIndex] = useState(initialIndex);

  // всегда держим актуальный initialIndex в ref (на случай, если deckCards пришли раньше)
  const initialIndexRef = useRef(initialIndex);
  useEffect(() => {
    initialIndexRef.current = initialIndex;
  }, [initialIndex]);

  const queueSig = useMemo(() => {
    if (!deckCards || deckCards.length === 0) return '';
    return deckCards.map(c => c.id).join('|');
  }, [deckCards]);

  const prevQueueSigRef = useRef<string>('');

  useEffect(() => {
    const nextCards = deckCards ?? [];
    setCards(nextCards);

    const prevSig = prevQueueSigRef.current;
    prevQueueSigRef.current = queueSig;

    // первичная загрузка очереди
    if (prevSig === '' && queueSig !== '') {
      const idx = clamp(initialIndexRef.current, 0, Math.max(0, nextCards.length - 1));
      setCurrentIndex(idx);
      return;
    }
    // если очередь реально изменилась (другая колода/другая сессия)
    if (prevSig !== '' && prevSig !== queueSig) {
      const idx = clamp(initialIndexRef.current, 0, Math.max(0, nextCards.length - 1));
      setCurrentIndex(idx);
      return;
    }
  }, [deckCards, queueSig]);

  const currentCard = cards[currentIndex] || null;
  const isCompleted = cards.length > 0 && currentIndex >= cards.length;

  const rateCard = async (rating: DifficultyRating) => {
    const card = currentCard;
    if (!card) return;

    try {
      await ApiClient.reviewCard(card.id, rating);
    } catch (err) {
      console.error('Failed to send rating:', err);
    }

    setCurrentIndex(prev => prev + 1);
  };

  const resetSession = () => setCurrentIndex(0);

  const skipCard = () => {
    setCurrentIndex((i) => Math.min(i + 1, cards.length)); // clamp
  };

  return { cards, currentIndex, setCurrentIndex, currentCard, isCompleted, rateCard, skipCard, resetSession };
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\public\icon.svg
==============================

<svg width="512" height="512" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
  <!-- Background -->
  <rect width="512" height="512" rx="110" fill="#4A6FA5"/>
  
  <!-- Card Stack -->
  <g filter="url(#shadow)">
    <!-- Back Card -->
    <rect x="120" y="150" width="280" height="200" rx="16" fill="#FFFFFF" opacity="0.3"/>
    
    <!-- Middle Card -->
    <rect x="110" y="165" width="280" height="200" rx="16" fill="#FFFFFF" opacity="0.6"/>
    
    <!-- Front Card -->
    <rect x="100" y="180" width="280" height="200" rx="16" fill="#FFFFFF"/>
    
    <!-- Card Content - Level Indicator -->
    <circle cx="150" cy="220" r="8" fill="#4A6FA5"/>
    <circle cx="170" cy="220" r="8" fill="#4A6FA5"/>
    <circle cx="190" cy="220" r="8" fill="#FF9A76"/>
    <circle cx="210" cy="220" r="8" fill="#E5E7EB"/>
    
    <!-- Card Content - Text Lines -->
    <rect x="120" y="260" width="200" height="12" rx="6" fill="#2D3748"/>
    <rect x="120" y="285" width="160" height="10" rx="5" fill="#718096"/>
    <rect x="120" y="305" width="140" height="10" rx="5" fill="#718096"/>
  </g>
  
  <!-- Accent Element -->
  <circle cx="360" cy="340" r="40" fill="#FF9A76" opacity="0.8"/>
  
  <defs>
    <filter id="shadow" x="80" y="140" width="320" height="260" filterUnits="userSpaceOnUse">
      <feGaussianBlur in="SourceAlpha" stdDeviation="10"/>
      <feOffset dy="4"/>
      <feComponentTransfer>
        <feFuncA type="linear" slope="0.2"/>
      </feComponentTransfer>
      <feMerge>
        <feMergeNode/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  </defs>
</svg>




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\public\manifest.json
==============================

{
  "name": "MenmonicFlow - Обучение по карточкам",
  "short_name": "MenmonicFlow",
  "description": "Образовательное приложение с карточками и интервальным повторением",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#F5F7FA",
  "theme_color": "#4A6FA5",
  "orientation": "portrait",
  "icons": [
    {
      "src": "/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ],
  "categories": ["education", "productivity"],
  "shortcuts": [
    {
      "name": "Начать обучение",
      "short_name": "Обучение",
      "description": "Начать новую сессию обучения",
      "url": "/study",
      "icons": [{ "src": "/icon-192.png", "sizes": "192x192" }]
    }
  ]
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\public\service-worker.js
==============================

const CACHE_NAME = 'adaptive-recall-v1';
const urlsToCache = [
  '/',
  '/index.html',
  '/styles/globals.css',
];

// Установка Service Worker
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('Opened cache');
        return cache.addAll(urlsToCache);
      })
  );
  self.skipWaiting();
});

// Активация Service Worker
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log('Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
  self.clients.claim();
});

// Перехват сетевых запросов
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        // Если есть в кеше - возвращаем из кеша
        if (response) {
          return response;
        }
        
        // Если нет в кеше - делаем сетевой запрос
        return fetch(event.request).then(
          (response) => {
            // Проверяем что получили валидный ответ
            if (!response || response.status !== 200 || response.type !== 'basic') {
              return response;
            }
            
            // Клонируем ответ для кеша
            const responseToCache = response.clone();
            
            caches.open(CACHE_NAME)
              .then((cache) => {
                cache.put(event.request, responseToCache);
              });
            
            return response;
          }
        );
      })
  );
});




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\auth\ForgotPasswordPage.tsx
==============================

import React, { useState } from 'react';

export function ForgotPasswordPage() {
  const [email, setEmail] = useState('');
  const [done, setDone] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const submit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);

    const res = await fetch('/api/auth/request-password-reset', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email }),
    });

    if (!res.ok) {
      setError(await res.text());
      return;
    }
    setDone(true);
  };

  if (done) return <div>Если email существует — ссылка для сброса отправлена.</div>;

  return (
    <form onSubmit={submit}>
      <h1>Восстановление пароля</h1>
      <input value={email} onChange={(e) => setEmail(e.target.value)} placeholder="Email" required />
      <button type="submit">Отправить ссылку</button>
      {error && <div>{error}</div>}
    </form>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\auth\Login.tsx
==============================

import React, { useState } from 'react';
import { Input } from '../../components/Input';
import { Button } from '../../components/Button/Button';
import { useAuth } from '../../auth/AuthContext';
import { login as loginApi } from '../../api/authClient';
import styles from './Login.module.css';

type Mode = 'login' | 'forgot';

export function Login({ onSwitch }: { onSwitch: () => void }) {
  const { login } = useAuth();

  const [mode, setMode] = useState<Mode>('login');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const [info, setInfo] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  const handleLogin = async () => {
    setLoading(true);
    setError(null);
    setInfo(null);

    try {
      const data = await loginApi(email, password);
      await login(data.access_token);
    } catch (e: unknown) {
      console.error('Login error:', e);
      const msg = e instanceof Error ? e.message : 'Ошибка входа';
      setError(msg || 'Ошибка входа');
    } finally {
      setLoading(false);
    }
  };

  const handleForgot = async () => {
    setLoading(true);
    setError(null);
    setInfo(null);

    try {
      const res = await fetch('/api/auth/request-password-reset', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email }),
      });

      const rawText = await res.text();
      let payload: any = null;
      try {
        payload = rawText ? JSON.parse(rawText) : null;
      } catch {
        payload = null;
      }

      if (!res.ok) {
        const msg =
          payload?.detail?.message ??
          payload?.detail ??
          rawText ??
          'Не удалось отправить ссылку';
        setError(String(msg));
        return;
      }

      setInfo('Если этот email существует, на него отправлена ссылка для сброса пароля.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className={styles.page}>
      <div className={styles.card}>
        <h1 className={styles.title}>
          {mode === 'login' ? 'Вход' : 'Восстановление пароля'}
        </h1>

        {error && <div className={styles.messageError}>{error}</div>}
        {info && <div className={styles.messageInfo}>{info}</div>}

        <Input label="Email" value={email} onChange={setEmail} />

        {mode === 'login' && (
          <form
            className={styles.form}
            onSubmit={(e) => {
              e.preventDefault();
              handleLogin();
            }}
          >
            <Input label="Пароль" type="password" value={password} onChange={setPassword} />

            <Button variant="primary" size="large" fullWidth disabled={loading} type="submit">
              {loading ? 'Входим...' : 'Войти'}
            </Button>

            <button
              onClick={() => {
                setMode('forgot');
                setError(null);
                setInfo(null);
              }}
              className={styles.linkBtn}
              type="button"
              disabled={loading}
            >
              Забыли пароль?
            </button>

            <button onClick={onSwitch} className={styles.linkBtn} type="button" disabled={loading}>
              Нет аккаунта? Зарегистрироваться
            </button>
          </form>
        )}

        {mode === 'forgot' && (
          <form
            className={styles.form}
            onSubmit={(e) => {
              e.preventDefault();
              handleForgot();
            }}
          >
            <Button variant="primary" size="large" fullWidth disabled={loading} type="submit">
              {loading ? 'Отправляем...' : 'Отправить ссылку'}
            </Button>

            <button
              onClick={() => {
                setMode('login');
                setError(null);
                setInfo(null);
              }}
              className={styles.linkBtn}
              type="button"
              disabled={loading}
            >
              Вернуться ко входу
            </button>
          </form>
        )}
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\auth\Register.tsx
==============================

import React, { useState } from 'react';
import { Input } from '../../components/Input';
import { Button } from '../../components/Button/Button';
import { register as registerApi } from '../../api/authClient';
import styles from './Register.module.css';

export function Register({ onSwitch }: { onSwitch: () => void }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const [info, setInfo] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  const handleSubmit = async () => {
    try {
      setLoading(true);
      setError(null);
      setInfo(null);

      const data = await registerApi(email, password);

      setInfo(data?.message ?? 'Регистрация успешна. Подтвердите email и затем войдите.');
      setPassword(''); // чтобы не оставлять пароль в поле
      // НЕ делаем onSwitch() автоматически, иначе ты не увидишь сообщение
    } catch (e: unknown) {
      const msg = e instanceof Error ? e.message : 'Ошибка регистрации';
      setError(msg || 'Ошибка регистрации');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className={styles.page}>
      <div className={styles.card}>
        <h1 className={styles.title}>Регистрация</h1>

        {error && <div className={styles.messageError}>{error}</div>}
        {info && <div className={styles.messageInfo}>{info}</div>}

        <form
          className={styles.form}
          onSubmit={(e) => {
            e.preventDefault();
            handleSubmit();
          }}
        >
          <Input label="Email" type="email" value={email} onChange={setEmail} disabled={loading} />
          <Input label="Пароль" type="password" value={password} onChange={setPassword} disabled={loading} />

          <Button variant="primary" size="large" fullWidth disabled={loading} type="submit">
            {loading ? 'Регистрируем...' : 'Зарегистрироваться'}
          </Button>

          <button onClick={onSwitch} className={styles.linkBtn} type="button" disabled={loading}>
            Уже есть аккаунт? Войти
          </button>
        </form>
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\auth\ResetPasswordPage.tsx
==============================

import React, { useEffect, useState } from 'react';

export function ResetPasswordPage({ token }: { token: string }) {
  const [password, setPassword] = useState('');
  const [status, setStatus] = useState<'idle' | 'ok' | 'error'>('idle');
  const [secondsLeft, setSecondsLeft] = useState(5);
  const [error, setError] = useState<string | null>(null);

  const submit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setStatus('idle');

    if (!token) {
      setStatus('error');
      setError('Токен не найден в ссылке');
      return;
    }

    const res = await fetch('/api/auth/reset-password', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ token, new_password: password }),
    });

    if (!res.ok) {
      let msg = 'Ошибка';
      try {
        msg = (await res.json()).detail ?? msg;
      } catch {}
      setError(msg);
      setStatus('error');
      return;
    }

    setStatus('ok');
  };

  // редирект через 5 секунд после успеха (аналогично verify-email)
  useEffect(() => {
    if (status !== 'ok') return;

    setSecondsLeft(5);

    const intervalId = window.setInterval(() => {
      setSecondsLeft((s) => (s > 0 ? s - 1 : 0));
    }, 1000);

    const timeoutId = window.setTimeout(() => {
      window.location.hash = '/'; // тот же hash-роут, что и в VerifyEmailPage
    }, 5000);

    return () => {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
    };
  }, [status]);

  if (!token) return <div>Токен не найден в ссылке</div>;

  if (status === 'ok') {
    return (
      <div>
        <div>Пароль изменён. Перенаправление на вход через {secondsLeft} сек…</div>
        <a href="/">Перейти на вход сейчас</a>
      </div>
    );
  }

  return (
    <form onSubmit={submit}>
      <h1>Новый пароль</h1>
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Введите новый пароль"
        required
      />
      <button type="submit">Сохранить</button>
      {error && <div>{error}</div>}
    </form>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\auth\VerifyEmailPage.tsx
==============================

import React, { useEffect, useState } from 'react';

export function VerifyEmailPage({ token }: { token: string }) {
  const [status, setStatus] = useState<'loading' | 'ok' | 'error'>('loading');
  const [secondsLeft, setSecondsLeft] = useState(5);

  // 1) проверка токена
  useEffect(() => {
    if (!token) {
      setStatus('error');
      return;
    }

    fetch('/api/auth/verify-email', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ token }),
    })
      .then((res) => setStatus(res.ok ? 'ok' : 'error'))
      .catch(() => setStatus('error'));
  }, [token]);

  // 2) редирект через 5 секунд после успеха
  useEffect(() => {
    if (status !== 'ok') return;

    setSecondsLeft(5);

    const intervalId = window.setInterval(() => {
      setSecondsLeft((s) => (s > 0 ? s - 1 : 0));
    }, 1000);

    const timeoutId = window.setTimeout(() => {
      // сюда поставь hash-роут твоего экрана логина/регистрации
      // если вход по умолчанию на "#/" — оставь так:
      window.location.hash = '/';
    }, 5000);

    return () => {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
    };
  }, [status]);

  if (status === 'loading') return <div>Проверяем токен…</div>;

  if (status === 'error') return (
    <div>
      Неверный или истёкший токен. <a href="/">Перейти ко входу</a>
    </div>
  );

  // status === 'ok'
  return (
    <div>
      <div>Email подтверждён. Перенаправление на вход через {secondsLeft} сек…</div>
      <a href="/">Перейти на вход сейчас</a>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\cards\CardsActionsContainer.tsx
==============================

import React from 'react';
import { ApiClient } from '../../api/client';

export type CardsActionsApi = {
  onCreateCardSave: (cardData: any) => Promise<void>;
  onCreateCardSaveMany: (cards: any[]) => Promise<{ created: number; failed: number; errors: string[] }>;
  onEditCardDone: () => void;
};


export function CardsActionsContainer({
  refreshDecks,
  refreshStats,
  closeCreateCard,
  closeEditCard,
  children,
}) {
  const onCreateCardSave = async (cardData) => {
    await ApiClient.createCard({
      deck_id: cardData.deckId,
      title: cardData.term,
      type: cardData.type,
      levels: cardData.levels,
    });

    refreshDecks();
    refreshStats();
    closeCreateCard();
  };

  const onCreateCardSaveMany = async (cards) => {
    const errors = [];
    let created = 0;

    for (let i = 0; i < cards.length; i++) {
      const c = cards[i];
      try {
        await ApiClient.createCard({
          deck_id: c.deckId,
          title: c.term,
          type: c.type,
          levels: c.levels,
        });
        created++;
      } catch (e) {
        errors.push(`${i}: ${String(e?.message ?? e)}`);
      }
    }

    refreshDecks();
    refreshStats();
    return { created, failed: errors.length, errors };
  };

  const onEditCardDone = () => {
    refreshDecks();
    refreshStats();
    closeEditCard();
  };

  return children({ onCreateCardSave, onCreateCardSaveMany, onEditCardDone });
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\cards\CardsFlowContainer.tsx
==============================

import React from 'react';

export type CardsFlowApi = {
  isCreatingCard: boolean;
  isEditingCard: boolean;
  openCreateCard: () => void;
  closeCreateCard: () => void;
  openEditCard: () => void;
  closeEditCard: () => void;
};

export function CardsFlowContainer({ children }: { children: (api: any) => React.ReactNode }) {
  const [isCreatingCard, setIsCreatingCard] = React.useState(false);
  const [isEditingCard, setIsEditingCard] = React.useState(false);

  const api = {
    isCreatingCard,
    isEditingCard,
    openCreateCard: () => setIsCreatingCard(true),
    closeCreateCard: () => setIsCreatingCard(false),
    openEditCard: () => setIsEditingCard(true),
    closeEditCard: () => setIsEditingCard(false),
  };

  return <>{children(api)}</>;
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\cards\CreateCard.tsx
==============================

// src/screens/CreateCard.tsx
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { Input } from '../../components/Input';
import { Button } from '../../components/Button/Button';
import { MarkdownField } from '../../components/MarkdownField';
import { X, Plus, Trash2, Upload } from 'lucide-react';
import type { PublicDeckSummary } from '../../types';
import { MarkdownView } from '../../components/MarkdownView';

type CardType = 'flashcard' | 'multiple_choice';

type LevelQA = { question: string; answer: string };

type McqOption = { id: string; text: string };
type LevelMCQ = {
  question: string;
  options: McqOption[];
  correctOptionId: string;
  explanation?: string;
  timerSec?: number;
};

type CsvRow = { name: string; front: string; back: string };

interface CreateCardProps {
  decks: PublicDeckSummary[];
  onSave: (cardData: { deckId: string; term: string; type: CardType; levels: any[] }) => void;

  onSaveMany: (
    cards: Array<{ deckId: string; term: string; type: 'flashcard'; levels: Array<{ question: string; answer: string }> }>
  ) => Promise<{ created: number; failed: number; errors?: string[] }>;

  onCancel: () => void;
}

const LAST_DECK_KEY = 'mnemonicFlow:lastDeckId';

function newId() {
  return Math.random().toString(16).slice(2);
}

function makeDefaultMcqLevel(): LevelMCQ {
  const a = newId();
  const b = newId();
  return {
    question: '',
    options: [
      { id: a, text: '' },
      { id: b, text: '' },
    ],
    correctOptionId: a,
    explanation: '',
    timerSec: undefined,
  };
}

function clampInt(n: number, min: number, max: number) {
  if (!Number.isFinite(n)) return min;
  return Math.max(min, Math.min(max, Math.trunc(n)));
}

/** Очень простой CSV: кавычки + запятая, без переносов строк внутри кавычек */
function splitCsvLine(line: string): string[] {
  const res: string[] = [];
  let cur = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const ch = line[i];

    if (ch === '"') {
      // "" -> "
      if (inQuotes && line[i + 1] === '"') {
        cur += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }

    if (ch === ',' && !inQuotes) {
      res.push(cur);
      cur = '';
      continue;
    }

    cur += ch;
  }

  res.push(cur);
  return res;
}

function parseCsvNameFrontBack(text: string): { rows: CsvRow[]; errors: string[]; total: number } {
  const errors: string[] = [];

  const rawLines = text.split(/\r?\n/);
  const lines = rawLines.filter(l => l.length > 0);

  if (lines.length === 0) return { rows: [], errors: ['CSV пустой'], total: 0 };

  const first = splitCsvLine(lines[0]).map(s => String(s).toLowerCase());
  const hasHeader = first.includes('name') && first.includes('front') && first.includes('back');

  let nameIdx = 0;
  let frontIdx = 1;
  let backIdx = 2;
  let start = 0;

  if (hasHeader) {
    nameIdx = first.indexOf('name');
    frontIdx = first.indexOf('front');
    backIdx = first.indexOf('back');
    start = 1;
  } else {
    if (first.length < 3) {
      return {
        rows: [],
        errors: ['Нет заголовка, но в первой строке меньше 3 колонок (нужно name,front,back).'],
        total: 0,
      };
    }
  }

  const total = Math.max(0, lines.length - start);
  const rows: CsvRow[] = [];

  for (let i = start; i < lines.length; i++) {
    const cols = splitCsvLine(lines[i]);

    const name = (cols[nameIdx] ?? '').trim();
    const front = (cols[frontIdx] ?? '').trim();
    const back = (cols[backIdx] ?? '').trim();

    if (!name || !front || !back) {
      errors.push(`Строка ${i + 1}: нужно заполнить name/front/back`);
      continue;
    }

    rows.push({ name, front, back });
  }

  return { rows, errors, total };
}

export function CreateCard({ decks, onSave, onSaveMany, onCancel }: CreateCardProps) {
  const [term, setTerm] = useState('');
  const [cardType, setCardType] = useState<CardType>('flashcard');

  const [activeLevel, setActiveLevel] = useState(0);

  const [deckId, setDeckId] = useState<string>(() => {
    const saved = localStorage.getItem(LAST_DECK_KEY);
    return saved ?? '';
  });

  // FLASHCARD levels
  const [levelsQA, setLevelsQA] = useState<LevelQA[]>([{ question: '', answer: '' }]);
  const [qPreview, setQPreview] = useState(false);
  const [aPreview, setAPreview] = useState(false);

  // MCQ levels
  const [levelsMCQ, setLevelsMCQ] = useState<LevelMCQ[]>([makeDefaultMcqLevel()]);
  const [mcqQPreview, setMcqQPreview] = useState(false);
  const [mcqOptionsPreview, setMcqOptionsPreview] = useState(false);
  const [mcqExplanationPreview, setMcqExplanationPreview] = useState(false);

  const levelsCount = cardType === 'flashcard' ? levelsQA.length : levelsMCQ.length;

  // CSV import
  const fileInputRef = useRef<HTMLInputElement | null>(null);
  const reportRef = useRef<HTMLDivElement | null>(null);

  const [importBusy, setImportBusy] = useState(false);
  const [importReport, setImportReport] = useState<string | null>(null);

  const scrollToReport = () => {
    setTimeout(() => reportRef.current?.scrollIntoView({ behavior: 'smooth', block: 'start' }), 0);
  };

  const handleAddLevel = () => {
    if (levelsCount >= 10) return;

    if (cardType === 'flashcard') {
      setLevelsQA(prev => [...prev, { question: '', answer: '' }]);
      setActiveLevel(levelsQA.length);
    } else {
      setLevelsMCQ(prev => [...prev, makeDefaultMcqLevel()]);
      setActiveLevel(levelsMCQ.length);
    }
  };

  const handleRemoveLevel = (index: number) => {
    if (levelsCount <= 1) return;

    if (cardType === 'flashcard') {
      const next = levelsQA.filter((_, i) => i !== index);
      setLevelsQA(next);
      if (activeLevel >= next.length) setActiveLevel(next.length - 1);
    } else {
      const next = levelsMCQ.filter((_, i) => i !== index);
      setLevelsMCQ(next);
      if (activeLevel >= next.length) setActiveLevel(next.length - 1);
    }
  };

  const patchLevelQA = (index: number, patch: Partial<LevelQA>) => {
    const next = [...levelsQA];
    next[index] = { ...next[index], ...patch };
    setLevelsQA(next);
  };

  const patchLevelMCQ = (index: number, patch: Partial<LevelMCQ>) => {
    const next = [...levelsMCQ];
    next[index] = { ...next[index], ...patch };
    setLevelsMCQ(next);
  };

  const patchMcqOption = (levelIndex: number, optionId: string, patch: Partial<McqOption>) => {
    const next = [...levelsMCQ];
    const lvl = next[levelIndex];
    const options = (lvl.options ?? []).map(o => (o.id === optionId ? { ...o, ...patch } : o));
    next[levelIndex] = { ...lvl, options };
    setLevelsMCQ(next);
  };

  const addMcqOption = (levelIndex: number) => {
    const next = [...levelsMCQ];
    const lvl = next[levelIndex];
    const optId = newId();
    const options = [...(lvl.options ?? []), { id: optId, text: '' }];
    next[levelIndex] = {
      ...lvl,
      options,
      correctOptionId: lvl.correctOptionId || optId,
    };
    setLevelsMCQ(next);
  };

  const removeMcqOption = (levelIndex: number, optionId: string) => {
    const next = [...levelsMCQ];
    const lvl = next[levelIndex];
    const options = (lvl.options ?? []).filter(o => o.id !== optionId);
    if (options.length < 2) return;

    let correctOptionId = lvl.correctOptionId;
    if (!options.some(o => o.id === correctOptionId)) {
      correctOptionId = options[0]?.id ?? '';
    }

    next[levelIndex] = { ...lvl, options, correctOptionId };
    setLevelsMCQ(next);
  };

  const cleanedLevelsQA = useMemo(
    () =>
      levelsQA
        .map(l => ({ question: l.question.trim(), answer: l.answer.trim() }))
        .filter(l => l.question && l.answer),
    [levelsQA]
  );

  const cleanedLevelsMCQ = useMemo(() => {
    return levelsMCQ
      .map(l => {
        const question = (l.question ?? '').trim();
        const options = (l.options ?? [])
          .map(o => ({ id: String(o.id), text: (o.text ?? '').trim() }))
          .filter(o => o.id);

        const correctOptionId = String(l.correctOptionId ?? '');
        const explanation = (l.explanation ?? '').trim();
        const timerSec =
          typeof l.timerSec === 'number' && l.timerSec > 0 ? clampInt(l.timerSec, 1, 3600) : undefined;

        return { question, options, correctOptionId, explanation, timerSec };
      })
      .filter(l => {
        if (!l.question) return false;
        if (l.options.length < 2) return false;
        const nonEmpty = l.options.filter(o => o.text);
        if (nonEmpty.length < 2) return false;
        if (!l.correctOptionId) return false;
        const correct = l.options.find(o => o.id === l.correctOptionId);
        if (!correct || !correct.text) return false;
        return true;
      });
  }, [levelsMCQ]);

  const canSave =
    term.trim() &&
    deckId &&
    (cardType === 'flashcard' ? cleanedLevelsQA.length > 0 : cleanedLevelsMCQ.length > 0);

  const handleSave = () => {
    if (!canSave) return;

    if (cardType === 'flashcard') {
      onSave({ deckId, term: term.trim(), type: 'flashcard', levels: cleanedLevelsQA });
    } else {
      onSave({ deckId, term: term.trim(), type: 'multiple_choice', levels: cleanedLevelsMCQ });
    }
  };

    const handleImportCsv = async (file: File) => {
    if (!deckId) return;

    setImportReport(null);
    setImportBusy(true);

    try {
      const text = await file.text();
      const { rows, errors, total } = parseCsvNameFrontBack(text);

      // 1) Если ошибки парсинга — ОТВЕРГАЕМ импорт полностью
      if (errors.length > 0) {
        const head = `Импорт отменён: ошибок парсинга ${errors.length} из ${total} строк.\nИсправь CSV и попробуй снова.`;
        const body =
          `\n\nОшибки:\n- ${errors.slice(0, 20).join('\n- ')}${errors.length > 20 ? '\n- ...' : ''}`;

        const msg = head + body;
        setImportReport(msg);
        alert(msg);
        return;
      }

      // 2) Парсинг ок → формируем payload и шлём
      const cards = rows.map((r) => ({
        deckId,
        term: r.name,
        type: 'flashcard' as const,
        levels: [{ question: r.front, answer: r.back }],
      }));

      const result = await onSaveMany(cards);

      const sent = cards.length;
      const created = result.created ?? 0;
      const failed = result.failed ?? 0;
      const apiErrors = result.errors ?? [];

      const tail =
        apiErrors.length > 0
          ? `\n\nОшибки API (index: message):\n- ${apiErrors.slice(0, 20).join('\n- ')}${
              apiErrors.length > 20 ? '\n- ...' : ''
            }`
          : '';

      const msg = `Импорт завершён: отправлено ${sent}, создано в базе ${created}, ошибок API ${failed}.${tail}`;
      setImportReport(msg);
      alert(msg);
    } catch (e: any) {
      const msg = `Импорт не удался: ${String(e?.message ?? e)}`;
      setImportReport(msg);
      alert(msg);
    } finally {
      setImportBusy(false);
    }
  };


  const activeQA = levelsQA[activeLevel];
  const activeMCQ = levelsMCQ[activeLevel];

  useEffect(() => {
    if (!decks || decks.length === 0) return;
    if (deckId && decks.some(d => d.deck_id === deckId)) return;
    setDeckId(decks[0].deck_id);
  }, [decks, deckId]);

  useEffect(() => {
    if (!deckId) return;
    localStorage.setItem(LAST_DECK_KEY, deckId);
  }, [deckId]);

  useEffect(() => {
    setActiveLevel(0);
    setQPreview(false);
    setAPreview(false);
    setMcqQPreview(false);
    setMcqOptionsPreview(false);
    setMcqExplanationPreview(false);
  }, [cardType]);

  return (
    <div className="min-h-screen bg-dark pb-24">
      <div className="page__header" style={{ position: 'sticky', top: 0, zIndex: 10 }}>
        <div className="page__header-inner">
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <button onClick={onCancel} style={{ color: '#9CA3AF', background: 'transparent', border: 0 }}>
              <X size={24} />
            </button>
            <h2 style={{ color: '#E8EAF0' }}>Новая карточка</h2>
            <div style={{ width: 24 }} />
          </div>
        </div>
      </div>

      <main className="container-centered w-full max-w-4xl space-y-6 py-6">
        <div className="form-row">
          <label className="form-label">Колода</label>
          <select
            value={deckId}
            onChange={(e) => setDeckId(e.target.value)}
            className="input"
            disabled={decks.length === 0}
          >
            {decks.length === 0 ? (
              <option value="">Нет доступных колод</option>
            ) : (
              decks.map(d => (
                <option key={d.deck_id} value={d.deck_id}>
                  {d.title}
                </option>
              ))
            )}
          </select>
        </div>

        <div className="form-row">
          <label className="form-label">Тип карточки</label>
          <select value={cardType} onChange={(e) => setCardType(e.target.value as CardType)} className="input">
            <option value="flashcard">Flashcard</option>
            <option value="multiple_choice">Multiple choice</option>
          </select>
        </div>

        <Input
          value={term}
          onChange={setTerm}
          label="Название / Тема карточки"
          placeholder="Например: Фотосинтез"
        />

        <div>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
            <label style={{ fontSize: '0.875rem', color: '#E8EAF0' }}>
              Уровни сложности ({levelsCount})
            </label>

            {levelsCount < 10 && (
              <button
                onClick={handleAddLevel}
                style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#4A6FA5', background: 'transparent', border: 0 }}
              >
                <Plus size={16} />
                Добавить уровень
              </button>
            )}
          </div>

          <div className="level-tabs">
            {Array.from({ length: levelsCount }).map((_, index) => (
              <button
                key={index}
                onClick={() => setActiveLevel(index)}
                className={`level-tab ${activeLevel === index ? 'level-tab--active' : 'level-tab--inactive'}`}
              >
                <span style={{ fontSize: '0.875rem' }}>Уровень {index + 1}</span>
              </button>
            ))}
          </div>

          <div className="card">
            <div className="flex items-center justify-between">
              <div style={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                {levelsCount > 1 && (
                  <button
                    onClick={() => handleRemoveLevel(activeLevel)}
                    style={{ color: '#E53E3E', padding: 4, background: 'transparent', border: 0 }}
                  >
                    <Trash2 size={16} />
                  </button>
                )}
              </div>
            </div>

            {cardType === 'flashcard' ? (
              <>
                <MarkdownField
                  label="Вопрос"
                  value={activeQA?.question ?? ''}
                  onChange={(v) => patchLevelQA(activeLevel, { question: v })}
                  preview={qPreview}
                  onTogglePreview={() => setQPreview(v => !v)}
                />

                <MarkdownField
                  label="Ответ"
                  value={activeQA?.answer ?? ''}
                  onChange={(v) => patchLevelQA(activeLevel, { answer: v })}
                  preview={aPreview}
                  onTogglePreview={() => setAPreview(v => !v)}
                  className="mt-4"
                />
              </>
            ) : (
              <>
                <MarkdownField
                  label="Вопрос"
                  value={activeMCQ?.question ?? ''}
                  onChange={(v) => patchLevelMCQ(activeLevel, { question: v })}
                  preview={mcqQPreview}
                  onTogglePreview={() => setMcqQPreview(v => !v)}
                />

                <div className="form-row" style={{ marginTop: '1rem' }}>
                  <label className="form-label">Таймер (сек) — опционально</label>
                  <input
                    className="input"
                    type="number"
                    min={0}
                    max={3600}
                    value={typeof activeMCQ?.timerSec === 'number' ? String(activeMCQ.timerSec) : ''}
                    onChange={(e) => {
                      const vRaw = e.target.value;
                      const v = vRaw === '' ? undefined : clampInt(Number(vRaw), 0, 3600);
                      patchLevelMCQ(activeLevel, { timerSec: v });
                    }}
                    placeholder="Напр. 15"
                  />
                </div>

                <div style={{ marginTop: '1rem' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <label className="form-label" style={{ marginBottom: 0 }}>
                      Варианты (выбери правильный)
                    </label>

                    <button
                      onClick={() => addMcqOption(activeLevel)}
                      style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#4A6FA5', background: 'transparent', border: 0 }}
                      type="button"
                    >
                      <Plus size={16} />
                      Добавить вариант
                    </button>
                  </div>

                  <div style={{ display: 'grid', gap: '0.75rem', marginTop: '0.75rem' }}>
                    {(activeMCQ?.options ?? []).map((opt, idx) => (
                      <div key={opt.id} className="card" style={{ padding: '0.75rem' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: 12, marginBottom: 8 }}>
                          <label style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#E8EAF0' }}>
                            <input
                              type="radio"
                              name={`mcq-correct-${activeLevel}`}
                              checked={String(activeMCQ?.correctOptionId) === String(opt.id)}
                              onChange={() => patchLevelMCQ(activeLevel, { correctOptionId: String(opt.id) })}
                            />
                            Правильный
                          </label>

                          <div style={{ flex: 1 }} />

                          <button
                            type="button"
                            onClick={() => removeMcqOption(activeLevel, opt.id)}
                            disabled={(activeMCQ?.options?.length ?? 0) <= 2}
                            style={{
                              color: (activeMCQ?.options?.length ?? 0) <= 2 ? '#6B7280' : '#E53E3E',
                              padding: 4,
                              background: 'transparent',
                              border: 0,
                            }}
                            title="Удалить вариант"
                          >
                            <Trash2 size={16} />
                          </button>
                        </div>

                        <MarkdownField
                          label={`Вариант ${idx + 1}`}
                          value={opt.text}
                          onChange={(v) => patchMcqOption(activeLevel, opt.id, { text: v })}
                          preview={mcqOptionsPreview}
                          onTogglePreview={() => setMcqOptionsPreview(v => !v)}
                        />
                      </div>
                    ))}
                  </div>

                  {(() => {
                    const correct = (activeMCQ?.options ?? []).find(o => o.id === activeMCQ?.correctOptionId);
                    const text = correct?.text?.trim();
                    if (!text) return null;
                    return (
                      <div style={{ marginTop: '1rem' }}>
                        <div style={{ color: '#9CA3AF', fontSize: '0.875rem', marginBottom: '0.5rem' }}>
                          Предпросмотр правильного ответа
                        </div>
                        <div className="card" style={{ padding: '0.75rem' }}>
                          <MarkdownView value={text} />
                        </div>
                      </div>
                    );
                  })()}
                </div>

                <MarkdownField
                  label="Пояснение (опционально)"
                  value={activeMCQ?.explanation ?? ''}
                  onChange={(v) => patchLevelMCQ(activeLevel, { explanation: v })}
                  preview={mcqExplanationPreview}
                  onTogglePreview={() => setMcqExplanationPreview(v => !v)}
                  className="mt-4"
                />
              </>
            )}
          </div>
        </div>

        <div style={{ display: 'flex', gap: '0.75rem', paddingTop: '1rem' }}>
          <Button
            onClick={() => fileInputRef.current?.click()}
            variant="secondary"
            size="large"
            fullWidth
            disabled={!deckId || importBusy}
          >
            <span style={{ display: 'inline-flex', alignItems: 'center', gap: 8 }}>
              <Upload size={16} />
              Импорт CSV
            </span>
          </Button>

          <Button onClick={onCancel} variant="secondary" size="large" fullWidth disabled={importBusy}>
            Отмена
          </Button>

          <Button onClick={handleSave} variant="primary" size="large" fullWidth disabled={!canSave || importBusy}>
            Сохранить
          </Button>
        </div>

        {importReport && (
          <div
            ref={reportRef}
            style={{
              color: '#9CA3AF',
              fontSize: '0.875rem',
              marginTop: '0.5rem',
              whiteSpace: 'pre-wrap',
            }}
          >
            {importReport}
          </div>
        )}

        <input
          ref={fileInputRef}
          type="file"
          accept=".csv,text/csv"
          style={{ display: 'none' }}
          onChange={async () => {
            const input = fileInputRef.current;
            const file = input?.files?.[0];
            if (!file) return;

            try {
              await handleImportCsv(file);
            } finally {
              if (fileInputRef.current) fileInputRef.current.value = '';
            }
          }}
        />
      </main>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\cards\EditCardFlow.tsx
==============================

import React, { useEffect, useMemo, useState } from 'react';
import type { PublicDeckSummary } from '../../types';
import { ApiClient } from '../../api/client';
import { Button } from '../../components/Button/Button';
import { MarkdownField } from '../../components/MarkdownField';
import { X, Plus, Trash2, ChevronUp, ChevronDown, Pencil } from 'lucide-react';
import { useAuth } from '../../auth/AuthContext';
import { getErrorMessage } from '../../utils/errorMessage';

type CardSummary = {
  card_id: string;
  title: string;
  type: string;
  levels?: Array<{ level_index: number; content: any }>;
};

interface Props {
  decks: PublicDeckSummary[];
  onCancel: () => void;
  onDone: () => void;
  onEditDeck?: (deckId: string) => void;
}

type QaLevelDraft = { kind: 'qa'; question: string; answer: string };
type McqOptionDraft = { id: string; text: string };
type McqLevelDraft = {
  kind: 'mcq';
  question: string;
  options: McqOptionDraft[];
  correctOptionId: string;
  explanation: string;
  timerSec: number; // 0 = без таймера
};
type LevelDraft = QaLevelDraft | McqLevelDraft;

function moveItem<T>(arr: T[], from: number, to: number): T[] {
  const next = [...arr];
  const [item] = next.splice(from, 1);
  next.splice(to, 0, item);
  return next;
}

function genId(): string {
  // crypto.randomUUID() не всегда доступен (в зависимости от окружения/браузера)
  // поэтому делаем безопасный fallback
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (typeof crypto !== 'undefined' && typeof (crypto as any).randomUUID === 'function') {
    return (crypto as any).randomUUID();
  }
  return `${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

const isMcqType = (t?: string) => {
  const s = (t ?? '').toLowerCase();
  return s === 'mcq' || s.includes('multiple_choice') || s.includes('multiple-choice') || s.includes('choice');
};

const getLevelIndex = (l: any) => {
  if (typeof l?.level_index === 'number') return l.level_index;
  if (typeof l?.levelIndex === 'number') return l.levelIndex;
  if (typeof l?.level_index === 'string') return Number(l.level_index) || 0;
  return 0;
};

function defaultQaLevel(): QaLevelDraft {
  return { kind: 'qa', question: '', answer: '' };
}

function defaultMcqLevel(): McqLevelDraft {
  const a = genId();
  const b = genId();
  return {
    kind: 'mcq',
    question: '',
    options: [
      { id: a, text: '' },
      { id: b, text: '' },
    ],
    correctOptionId: '',
    explanation: '',
    timerSec: 0,
  };
}

function isLevelEmpty(level: LevelDraft): boolean {
  if (level.kind === 'qa') {
    const q = level.question.trim();
    const a = level.answer.trim();
    return !q || !a;
  }

  const q = level.question.trim();
  const opts = level.options.map(o => ({ ...o, text: o.text.trim() })).filter(o => o.text);
  const correctOk = opts.some(o => o.id === level.correctOptionId);
  return !q || opts.length < 2 || !correctOk;
}

function normalizeMcqLevel(rawContent: any): McqLevelDraft {
  const c = rawContent ?? {};
  const rawOptions = Array.isArray(c.options) ? c.options : [];

  const options: McqOptionDraft[] =
    rawOptions.length > 0
      ? rawOptions.map((o: any) => ({
          id: String(o?.id ?? genId()),
          text: String(o?.text ?? o?.label ?? ''),
        }))
      : [
          { id: genId(), text: '' },
          { id: genId(), text: '' },
        ];

  const correctOptionId = String(c.correctOptionId ?? c.correct_option_id ?? '');

  return {
    kind: 'mcq',
    question: String(c.question ?? ''),
    options,
    correctOptionId,
    explanation: String(c.explanation ?? ''),
    timerSec: Number(c.timerSec ?? c.timer_sec ?? 0) || 0,
  };
}

function normalizeQaLevel(rawContent: any): QaLevelDraft {
  const c = rawContent ?? {};
  return {
    kind: 'qa',
    question: String(c.question ?? ''),
    answer: String(c.answer ?? ''),
  };
}

export function EditCardFlow({ decks, onCancel, onDone, onEditDeck }: Props) {
  const defaultDeckId = useMemo(() => decks?.[0]?.deck_id ?? '', [decks]);
  const [deckId, setDeckId] = useState(defaultDeckId);

  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [errorText, setErrorText] = useState<string | null>(null);

  const [cards, setCards] = useState<CardSummary[]>([]);
  const [selectedCardId, setSelectedCardId] = useState<string>('');

  const selectedCard = useMemo(
    () => cards.find(c => c.card_id === selectedCardId) || null,
    [cards, selectedCardId]
  );

  const [activeLevel, setActiveLevel] = useState(0);
  const [levels, setLevels] = useState<LevelDraft[]>([defaultQaLevel()]);
  const [titleDraft, setTitleDraft] = useState('');

  const [qPreview, setQPreview] = useState(false);
  const [aPreview, setAPreview] = useState(false);

  const { currentUser } = useAuth();

  // если decks пришли позже и deckId пустой — выставим дефолт
  useEffect(() => {
    if (!deckId && defaultDeckId) setDeckId(defaultDeckId);
  }, [deckId, defaultDeckId]);

  // загрузка карточек выбранной колоды
  useEffect(() => {
    if (!deckId) return;

    (async () => {
      setLoading(true);
      setErrorText(null);
      try {
        const deck = await ApiClient.getDeckWithCards(deckId);
        setCards(deck.cards);
        setSelectedCardId('');
        setLevels([defaultQaLevel()]);
        setActiveLevel(0);
      } catch (e: unknown) {
        setErrorText(getErrorMessage(e) || 'Ошибка загрузки карточек');
        setCards([]);
        setSelectedCardId('');
      } finally {
        setLoading(false);
      }
    })();
  }, [deckId]);

  // когда выбрали карточку — заполняем уровни (по индексу) и типу карточки
  useEffect(() => {
    if (!selectedCard) return;

    const sorted = [...(selectedCard.levels ?? [])].sort((a, b) => getLevelIndex(a) - getLevelIndex(b));

    if (isMcqType(selectedCard.type)) {
      const mapped: LevelDraft[] =
        sorted.length > 0 ? sorted.map(l => normalizeMcqLevel(l.content)) : [defaultMcqLevel()];
      setLevels(mapped);
    } else {
      const mapped: LevelDraft[] =
        sorted.length > 0 ? sorted.map(l => normalizeQaLevel(l.content)) : [defaultQaLevel()];
      setLevels(mapped);
    }

    setActiveLevel(0);
    setQPreview(false);
    setAPreview(false);
  }, [selectedCardId]); // eslint-disable-line react-hooks/exhaustive-deps

  useEffect(() => {
    const c = cards.find(x => x.card_id === selectedCardId);
    setTitleDraft(c?.title ?? '');
  }, [selectedCardId, cards]);

  const patchLevel = (index: number, patch: Partial<LevelDraft>) => {
    setLevels(prev => {
      const next = [...prev];
      next[index] = { ...(next[index] as any), ...(patch as any) };
      return next;
    });
  };

  const addLevel = () => {
    if (levels.length >= 10) return;

    const nextLevel: LevelDraft = isMcqType(selectedCard?.type) ? defaultMcqLevel() : defaultQaLevel();
    setLevels(prev => [...prev, nextLevel]);
    setActiveLevel(levels.length);
  };

  const removeLevel = (index: number) => {
    if (levels.length <= 1) return;

    setLevels(prev => prev.filter((_, i) => i !== index));
    setActiveLevel(prev => {
      const nextLen = levels.length - 1;
      return Math.min(prev, nextLen - 1);
    });
  };

  // Перемещение уровня с корректной поправкой activeLevel
  const moveLevel = (from: number, to: number) => {
    if (to < 0 || to >= levels.length || from === to) return;

    setLevels(prev => moveItem(prev, from, to));

    setActiveLevel(prev => {
      if (prev === from) return to;
      if (from < to && prev > from && prev <= to) return prev - 1;
      if (to < from && prev >= to && prev < from) return prev + 1;
      return prev;
    });
  };

  // ---- MCQ helpers ----
  const addOption = () => {
    setLevels(prev => {
      const next = [...prev];
      const lvl = next[activeLevel];
      if (!lvl || lvl.kind !== 'mcq') return prev;
      if (lvl.options.length >= 8) return prev;

      next[activeLevel] = {
        ...lvl,
        options: [...lvl.options, { id: genId(), text: '' }],
      };
      return next;
    });
  };

  const removeOption = (optIndex: number) => {
    setLevels(prev => {
      const next = [...prev];
      const lvl = next[activeLevel];
      if (!lvl || lvl.kind !== 'mcq') return prev;
      if (lvl.options.length <= 2) return prev;

      const removed = lvl.options[optIndex];
      const options = lvl.options.filter((_, i) => i !== optIndex);

      next[activeLevel] = {
        ...lvl,
        options,
        correctOptionId: removed?.id === lvl.correctOptionId ? '' : lvl.correctOptionId,
      };
      return next;
    });
  };

  const patchOptionText = (optIndex: number, text: string) => {
    setLevels(prev => {
      const next = [...prev];
      const lvl = next[activeLevel];
      if (!lvl || lvl.kind !== 'mcq') return prev;

      const options = [...lvl.options];
      options[optIndex] = { ...options[optIndex], text };

      next[activeLevel] = { ...lvl, options };
      return next;
    });
  };

  const moveOption = (from: number, to: number) => {
    setLevels(prev => {
      const next = [...prev];
      const lvl = next[activeLevel];
      if (!lvl || lvl.kind !== 'mcq') return prev;
      if (to < 0 || to >= lvl.options.length || from === to) return prev;

      next[activeLevel] = { ...lvl, options: moveItem(lvl.options, from, to) };
      return next;
    });
  };

  // ---- validation / cleaned ----
  const cleaned = useMemo(() => {
    const nonEmpty = levels.filter(l => !isLevelEmpty(l));
    return nonEmpty;
  }, [levels]);

  const canSave = Boolean(selectedCard) && cleaned.length > 0 && !saving;

  const buildApiLevels = () => {
    // сохраняем только “непустые” уровни, как было раньше (пустые не сохраняем)
    const usable = levels.filter(l => !isLevelEmpty(l));

    return usable.map((lvl, level_index) => {
      const content =
        lvl.kind === 'qa'
          ? {
              question: lvl.question.trim(),
              answer: lvl.answer.trim(),
            }
          : {
              question: lvl.question.trim(),
              options: lvl.options.map(o => ({ id: o.id, text: o.text.trim() })).filter(o => o.text),
              correctOptionId: lvl.correctOptionId,
              explanation: lvl.explanation,
              timerSec: lvl.timerSec,
            };

      return { level_index, content };
    });
  };

  const saveCard = async () => {
    if (!selectedCardId) return;

    const token = localStorage.getItem('access_token');
    if (!token) throw new Error('No auth token');

    setSaving(true);
    setErrorText(null);

    try {
      const t = titleDraft.trim();
      if (!t) throw new Error('Название обязательно');

      const patchRes = await fetch(`/api/cards/${selectedCardId}?title=${encodeURIComponent(t)}`, {
        method: 'PATCH',
        headers: { Authorization: `Bearer ${token}` },
      });
      if (!patchRes.ok) throw new Error(await patchRes.text());

      const apiLevels = buildApiLevels();

      await ApiClient.replaceCardLevels(selectedCardId, apiLevels);

      setCards(prev => prev.map(c => (c.card_id === selectedCardId ? { ...c, title: t } : c)));
    } catch (e: any) {
      setErrorText(e?.message ?? 'Ошибка сохранения');
    } finally {
      setSaving(false);
    }
  };

  const humanizeDeleteError = (e: any, what: 'card' | 'deck') => {
    const status = e?.status;
    if (status === 403)
      return what === 'card' ? 'Нельзя удалить карточку: вы не хозяин.' : 'Нельзя удалить колоду: вы не хозяин.';
    if (status === 404) return 'Объект не найден (возможно, уже удалён).';
    return e?.message ?? 'Ошибка удаления';
  };

  const deleteSelectedCard = async () => {
    if (!selectedCard) return;
    if (!window.confirm('Удалить карточку?')) return;

    setSaving(true);
    setErrorText(null);
    try {
      await ApiClient.deleteCard(selectedCard.card_id);

      setCards(prev => prev.filter(c => c.card_id !== selectedCard.card_id));
      setSelectedCardId('');
      setLevels([defaultQaLevel()]);
      setActiveLevel(0);
    } catch (e: any) {
      setErrorText(humanizeDeleteError(e, 'card'));
    } finally {
      setSaving(false);
    }
  };

  const deleteCurrentDeck = async () => {
    if (!deckId) return;
    if (!window.confirm('Удалить колоду и все её карточки?')) return;

    setSaving(true);
    setErrorText(null);
    try {
      await ApiClient.deleteDeck(deckId);

      setCards([]);
      setSelectedCardId('');
      setLevels([defaultQaLevel()]);
      setActiveLevel(0);

      onDone();
    } catch (e: any) {
      setErrorText(humanizeDeleteError(e, 'deck'));
    } finally {
      setSaving(false);
    }
  };

  const active = levels[activeLevel];

  return (
    <div className="min-h-screen bg-dark pb-24">
      <div className="page__header" style={{ position: 'sticky', top: 0, zIndex: 10 }}>
        <div className="page__header-inner">
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <button onClick={onCancel} style={{ color: '#9CA3AF', background: 'transparent', border: 0 }}>
              <X size={24} />
            </button>
            <h2 style={{ color: '#E8EAF0' }}>Редактирование уровней</h2>
            <div style={{ width: 24 }} />
          </div>
        </div>
      </div>

      <main className="container-centered max-w-390 space-y-6 py-6">
        {errorText && (
          <div className="card" style={{ border: '1px solid rgba(229,62,62,0.4)' }}>
            <div style={{ color: '#FEB2B2' }}>{errorText}</div>
          </div>
        )}

        {/* Deck */}
        <div className="form-row">
          <label className="form-label">Колода</label>

          <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
            <select
              value={deckId}
              onChange={e => setDeckId(e.target.value)}
              className="input"
              disabled={decks.length === 0 || saving}
              style={{ flex: 1 }}
            >
              {decks.length === 0 ? (
                <option value="">Нет доступных колод</option>
              ) : (
                decks.map(d => (
                  <option key={d.deck_id} value={d.deck_id}>
                    {d.title}
                  </option>
                ))
              )}
            </select>

            <button
              onClick={deleteCurrentDeck}
              disabled={!deckId || decks.length === 0 || saving}
              title="Удалить колоду"
              style={{
                width: 44,
                height: 44,
                borderRadius: 10,
                border: '1px solid rgba(229,62,62,0.35)',
                background: 'transparent',
                color: '#E53E3E',
                opacity: !deckId || decks.length === 0 || saving ? 0.4 : 1,
              }}
            >
              <Trash2 size={18} />
            </button>

            {/* Edit deck button (shows only for owner) */}
            {(() => {
              const currentDeck = decks.find(d => d.deck_id === deckId);
              const isOwner = !!(currentDeck && currentUser && currentUser.id === (currentDeck as any).owner_id);
              return isOwner && onEditDeck && deckId ? (
                <button
                  onClick={e => {
                    e.stopPropagation();
                    onEditDeck(deckId);
                  }}
                  title="Редактировать колоду"
                  style={{
                    width: 44,
                    height: 44,
                    borderRadius: 10,
                    border: '1px solid rgba(156,163,175,0.12)',
                    background: 'transparent',
                    color: '#E8EAF0',
                  }}
                >
                  <Pencil size={18} />
                </button>
              ) : null;
            })()}
          </div>
        </div>

        {/* Card */}
        <div className="form-row">
          <label className="form-label">Карточка</label>

          <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
            <select
              value={selectedCardId}
              onChange={e => setSelectedCardId(e.target.value)}
              className="input"
              disabled={loading || cards.length === 0 || saving}
              style={{ flex: 1 }}
            >
              <option value="">{loading ? 'Загрузка…' : 'Выбери карточку'}</option>
              {cards.map(c => (
                <option key={c.card_id} value={c.card_id}>
                  {c.title}
                </option>
              ))}
            </select>

            <button
              onClick={deleteSelectedCard}
              disabled={!selectedCard || saving}
              title="Удалить карточку"
              style={{
                width: 44,
                height: 44,
                borderRadius: 10,
                border: '1px solid rgba(229,62,62,0.35)',
                background: 'transparent',
                color: '#E53E3E',
                opacity: !selectedCard || saving ? 0.4 : 1,
              }}
            >
              <Trash2 size={18} />
            </button>
          </div>
        </div>

        {!selectedCard ? null : (
          <>
            <div className="form-row">
              <label className="form-label">Название</label>
              <input
                className="input"
                value={titleDraft}
                onChange={e => setTitleDraft(e.target.value)}
                disabled={!selectedCardId || saving}
              />
            </div>

            <div>
              <div
                style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  marginBottom: '0.75rem',
                }}
              >
                <label style={{ fontSize: '0.875rem', color: '#E8EAF0' }}>Уровни ({levels.length})</label>

                {levels.length < 10 && (
                  <button
                    onClick={addLevel}
                    style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#4A6FA5', background: 'transparent', border: 0 }}
                  >
                    <Plus size={16} />
                    Добавить уровень
                  </button>
                )}
              </div>

              {/* Вкладки уровней + перемещение */}
              <div className="level-tabs">
                {levels.map((_, index) => {
                  const isActive = activeLevel === index;

                  return (
                    <div
                      key={index}
                      onClick={() => setActiveLevel(index)}
                      className={`level-tab ${isActive ? 'level-tab--active' : 'level-tab--inactive'}`}
                      role="button"
                      tabIndex={0}
                      onKeyDown={e => {
                        if (e.key === 'Enter' || e.key === ' ') setActiveLevel(index);
                      }}
                      style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 10 }}
                    >
                      <span style={{ fontSize: '0.875rem' }}>Уровень {index + 1}</span>

                      <div style={{ display: 'flex', alignItems: 'center', gap: 6 }}>
                        <span
                          onClick={e => {
                            e.stopPropagation();
                            moveLevel(index, index - 1);
                          }}
                          title="Вверх"
                          style={{
                            display: 'inline-flex',
                            padding: 4,
                            color: '#9CA3AF',
                            opacity: index === 0 ? 0.35 : 1,
                            pointerEvents: index === 0 ? 'none' : 'auto',
                          }}
                        >
                          <ChevronUp size={16} />
                        </span>

                        <span
                          onClick={e => {
                            e.stopPropagation();
                            moveLevel(index, index + 1);
                          }}
                          title="Вниз"
                          style={{
                            display: 'inline-flex',
                            padding: 4,
                            color: '#9CA3AF',
                            opacity: index === levels.length - 1 ? 0.35 : 1,
                            pointerEvents: index === levels.length - 1 ? 'none' : 'auto',
                          }}
                        >
                          <ChevronDown size={16} />
                        </span>
                      </div>
                    </div>
                  );
                })}
              </div>

              {/* Редактор активного уровня */}
              <div className="card">
                <div className="flex items-center justify-between">
                  <div />
                  <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                    <button
                      onClick={() => moveLevel(activeLevel, activeLevel - 1)}
                      disabled={activeLevel === 0}
                      style={{
                        color: '#9CA3AF',
                        padding: 4,
                        background: 'transparent',
                        border: 0,
                        opacity: activeLevel === 0 ? 0.35 : 1,
                      }}
                      title="Вверх"
                    >
                      <ChevronUp size={16} />
                    </button>

                    <button
                      onClick={() => moveLevel(activeLevel, activeLevel + 1)}
                      disabled={activeLevel === levels.length - 1}
                      style={{
                        color: '#9CA3AF',
                        padding: 4,
                        background: 'transparent',
                        border: 0,
                        opacity: activeLevel === levels.length - 1 ? 0.35 : 1,
                      }}
                      title="Вниз"
                    >
                      <ChevronDown size={16} />
                    </button>

                    {levels.length > 1 && (
                      <button
                        onClick={() => removeLevel(activeLevel)}
                        style={{ color: '#E53E3E', padding: 4, background: 'transparent', border: 0 }}
                        title="Удалить уровень"
                      >
                        <Trash2 size={16} />
                      </button>
                    )}
                  </div>
                </div>

                {/* --- QA --- */}
                {active.kind === 'qa' ? (
                  <>
                    <MarkdownField
                      label="Вопрос"
                      value={active.question}
                      onChange={v => patchLevel(activeLevel, { question: v } as any)}
                      preview={qPreview}
                      onTogglePreview={() => setQPreview(v => !v)}
                      disabled={saving}
                    />

                    <MarkdownField
                      label="Ответ"
                      value={active.answer}
                      onChange={v => patchLevel(activeLevel, { answer: v } as any)}
                      preview={aPreview}
                      onTogglePreview={() => setAPreview(v => !v)}
                      disabled={saving}
                      className="mt-4"
                    />
                  </>
                ) : (
                  /* --- MCQ --- */
                  <>
                    <MarkdownField
                      label="Вопрос"
                      value={active.question}
                      onChange={v => patchLevel(activeLevel, { question: v } as any)}
                      preview={qPreview}
                      onTogglePreview={() => setQPreview(v => !v)}
                      disabled={saving}
                    />

                    <div style={{ marginTop: 12 }}>
                      <label className="form-label">Варианты</label>

                      {active.options.map((o, i) => (
                        <div key={o.id} style={{ display: 'flex', gap: 8, alignItems: 'center', marginBottom: 8 }}>
                          <input
                            className="input"
                            value={o.text}
                            onChange={e => patchOptionText(i, e.target.value)}
                            disabled={saving}
                            placeholder={`Вариант ${i + 1}`}
                            style={{ flex: 1 }}
                          />

                          <button
                            onClick={() => moveOption(i, i - 1)}
                            disabled={i === 0 || saving}
                            title="Вверх"
                            style={{
                              width: 40,
                              height: 40,
                              borderRadius: 10,
                              border: '1px solid rgba(156,163,175,0.12)',
                              background: 'transparent',
                              color: '#9CA3AF',
                              opacity: i === 0 || saving ? 0.35 : 1,
                            }}
                          >
                            <ChevronUp size={16} />
                          </button>

                          <button
                            onClick={() => moveOption(i, i + 1)}
                            disabled={i === active.options.length - 1 || saving}
                            title="Вниз"
                            style={{
                              width: 40,
                              height: 40,
                              borderRadius: 10,
                              border: '1px solid rgba(156,163,175,0.12)',
                              background: 'transparent',
                              color: '#9CA3AF',
                              opacity: i === active.options.length - 1 || saving ? 0.35 : 1,
                            }}
                          >
                            <ChevronDown size={16} />
                          </button>

                          <button
                            onClick={() => removeOption(i)}
                            disabled={active.options.length <= 2 || saving}
                            title="Удалить вариант"
                            style={{
                              width: 40,
                              height: 40,
                              borderRadius: 10,
                              border: '1px solid rgba(229,62,62,0.35)',
                              background: 'transparent',
                              color: '#E53E3E',
                              opacity: active.options.length <= 2 || saving ? 0.35 : 1,
                            }}
                          >
                            <Trash2 size={16} />
                          </button>
                        </div>
                      ))}

                      <button
                        onClick={addOption}
                        disabled={saving || active.options.length >= 8}
                        style={{ display: 'flex', alignItems: 'center', gap: 8, color: '#4A6FA5', background: 'transparent', border: 0 }}
                      >
                        <Plus size={16} />
                        Добавить вариант
                      </button>
                    </div>

                    <div style={{ marginTop: 12 }}>
                      <label className="form-label">Правильный вариант</label>
                      <select
                        className="input"
                        value={active.correctOptionId}
                        onChange={e => patchLevel(activeLevel, { correctOptionId: e.target.value } as any)}
                        disabled={saving}
                      >
                        <option value="">— выбери —</option>
                        {active.options.map(o => (
                          <option key={o.id} value={o.id}>
                            {o.text || o.id}
                          </option>
                        ))}
                      </select>
                    </div>

                    <div style={{ marginTop: 12 }}>
                      <label className="form-label">Таймер (сек)</label>
                      <input
                        className="input"
                        type="number"
                        min={0}
                        value={active.timerSec}
                        onChange={e => patchLevel(activeLevel, { timerSec: Number(e.target.value) || 0 } as any)}
                        disabled={saving}
                      />
                      <div style={{ color: '#9CA3AF', fontSize: '0.8rem', marginTop: 6 }}>
                        0 = без таймера (карточка не будет автопереворачиваться по времени).
                      </div>
                    </div>

                    <MarkdownField
                      label="Пояснение (показывать на обороте)"
                      value={active.explanation}
                      onChange={v => patchLevel(activeLevel, { explanation: v } as any)}
                      preview={aPreview}
                      onTogglePreview={() => setAPreview(v => !v)}
                      disabled={saving}
                      className="mt-4"
                    />
                  </>
                )}
              </div>

              {/* Подсказка про пустые уровни */}
              {levels.length !== cleaned.length && (
                <div className="card">
                  <div style={{ color: '#9CA3AF', fontSize: '0.875rem' }}>
                    Пустые уровни (недозаполненные) не будут сохранены.
                  </div>
                </div>
              )}
            </div>

            <div style={{ display: 'flex', gap: '0.75rem', paddingTop: '1rem' }}>
              <Button onClick={onCancel} variant="secondary" size="large" fullWidth disabled={saving}>
                Отмена
              </Button>
              <Button onClick={saveCard} variant="primary" size="large" fullWidth disabled={!canSave}>
                {saving ? 'Сохранение…' : 'Сохранить'}
              </Button>
            </div>
          </>
        )}
      </main>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\cards\index.ts
==============================

export { CreateCard } from './CreateCard';
export { EditCardFlow } from './EditCardFlow';
export { CardsActionsContainer } from './CardsActionsContainer';
export { CardsFlowContainer } from './CardsFlowContainer';
export type { CardsActionsApi } from './CardsActionsContainer';
export type { CardsFlowApi } from './CardsFlowContainer';



==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\dashboard\dashboard.types.ts
==============================

import { Statistics, Deck, Group } from '../../types';

export type ResumeSessionProps = {
  title: string;
  subtitle: string;
  cardInfo: string;
  onResume: () => void;
  onDiscard: () => void;
};

export type DashboardModel = {
  statistics: Statistics;
  decks: Deck[];
  groups: Group[];
  activeGroupId: string | null;
  resumeSession?: ResumeSessionProps;
};

export type DashboardActions = {
  onGroupChange: (groupId: string) => void;
  onStartStudy: () => void;
  onDeckClick: (deckId: string) => void;
  onEditDeck?: (deckId: string) => void;

  onCreateGroup: () => void;
  onDeleteActiveGroup: () => void;

  onAddDeck: () => void;
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\dashboard\DashboardContainer.tsx
==============================

// src\screens\dashboard\DashboardContainer.tsx
import React from 'react';
import type { Deck, Group, Statistics } from '../../types';
import type { PersistedSession } from '../../utils/sessionStore';
import { DashboardView } from './DashboardView';
import type { DashboardActions, DashboardModel, ResumeSessionProps } from './dashboard.types';

type Props = {
  statistics: Statistics;
  decks: Deck[];
  groups: Group[];
  activeGroupId: string | null;

  resumeCandidate: PersistedSession | null;
  onResume: () => void;
  onDiscardResume: () => void;

  onGroupChange: (groupId: string) => void;
  onCreateGroup: () => void;
  onDeleteActiveGroup: () => void;

  onStartStudy: () => void;
  onDeckClick: (deckId: string) => void;
  onOpenEditDeck: (deckId: string) => void;

  onAddDeck: () => void; // тут уже нормальное имя
};

function buildResumeSession(
  resume: PersistedSession,
  decks: Deck[],
  onResume: () => void,
  onDiscard: () => void
): ResumeSessionProps {
  const subtitle =
    resume.mode === 'review'
      ? 'Учебная сессия'
      : (decks.find((d) => d.deck_id === resume.activeDeckId)?.title ?? 'Колода');

  return {
    title: 'Продолжить сессию',
    subtitle,
    cardInfo: `Карточка ${resume.currentIndex + 1} из ${resume.deckCards.length}`,
    onResume,
    onDiscard,
  };
}

export function DashboardContainer(props: Props) {
  const resumeSession = props.resumeCandidate
    ? buildResumeSession(props.resumeCandidate, props.decks, props.onResume, props.onDiscardResume)
    : undefined;

  const model: DashboardModel = {
    statistics: props.statistics,
    decks: props.decks,
    groups: props.groups,
    activeGroupId: props.activeGroupId,
    resumeSession,
  };

  const actions: DashboardActions = {
    onGroupChange: props.onGroupChange,
    onStartStudy: props.onStartStudy,
    onDeckClick: props.onDeckClick,
    onEditDeck: props.onOpenEditDeck,
    onCreateGroup: props.onCreateGroup,
    onDeleteActiveGroup: props.onDeleteActiveGroup,
    onAddDeck: props.onAddDeck,
  };

  return <DashboardView model={model} actions={actions} />;
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\dashboard\DashboardView.tsx
==============================

import React from 'react';
import { Button } from '../../components/Button/Button';
import { ResumeSessionCard } from '../../components/ResumeSession';
import type { DashboardActions, DashboardModel } from './dashboard.types';
import { DashboardStats } from './components/DashboardStats';
import { GroupsBar } from './components/GroupsBar';
import { DeckList } from './components/DeckList';
import './Dashboard.css';

export function DashboardView({ model, actions }: { model: DashboardModel; actions: DashboardActions }) {
  return (
    <div className="dashboard">
      <div className="dashboard__header">
        <div className="dashboard__header-inner">
          <DashboardStats statistics={model.statistics} />
        </div>
      </div>

      {model.resumeSession && <ResumeSessionCard {...model.resumeSession} />}

      <div className="dashboard__action-section">
        <Button onClick={actions.onStartStudy} variant="primary" size="large" fullWidth>
          Начать обучение
        </Button>
      </div>

      <GroupsBar
        groups={model.groups}
        activeGroupId={model.activeGroupId}
        onGroupChange={actions.onGroupChange}
        onCreateGroup={actions.onCreateGroup}
        onDeleteActiveGroup={actions.onDeleteActiveGroup}
      />

      <DeckList decks={model.decks} onDeckClick={actions.onDeckClick} onEditDeck={actions.onEditDeck} />

      <div className="dashboard__footer-section">
        <Button onClick={actions.onAddDeck} variant="primary" size="medium" fullWidth>
          Добавить колоду
        </Button>
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\dashboard\index.ts
==============================

export { DashboardView } from './DashboardView';
export { DashboardContainer } from './DashboardContainer';
export * from './dashboard.types';




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\dashboard\useGroupsCarousel.ts
==============================

import * as React from 'react';

export function useGroupsCarousel() {
  const carouselRef = React.useRef<HTMLDivElement | null>(null);
  const isDownRef = React.useRef(false);
  const startXRef = React.useRef(0);
  const scrollLeftRef = React.useRef(0);

  const onWheelCarousel = React.useCallback((e: React.WheelEvent<HTMLDivElement>) => {
    if (!carouselRef.current) return;
    carouselRef.current.scrollBy({ left: e.deltaY, behavior: 'smooth' });
  }, []);

  const onMouseDown = React.useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    if (!carouselRef.current) return;
    isDownRef.current = true;
    carouselRef.current.classList.add('dragging');
    startXRef.current = e.pageX - carouselRef.current.offsetLeft;
    scrollLeftRef.current = carouselRef.current.scrollLeft;
  }, []);

  const onMouseMove = React.useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    if (!isDownRef.current || !carouselRef.current) return;
    e.preventDefault();
    const x = e.pageX - carouselRef.current.offsetLeft;
    const walk = (x - startXRef.current) * 1;
    carouselRef.current.scrollLeft = scrollLeftRef.current - walk;
  }, []);

  const onMouseUpOrLeave = React.useCallback(() => {
    if (!carouselRef.current) return;
    isDownRef.current = false;
    carouselRef.current.classList.remove('dragging');
  }, []);

  return { carouselRef, onWheelCarousel, onMouseDown, onMouseMove, onMouseUpOrLeave };
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\dashboard\components\DashboardStats.tsx
==============================

import React from 'react';
import { Clock, BookOpen, Flame } from 'lucide-react';
import type { Statistics } from '../../../types';

export function DashboardStats({ statistics }: { statistics: Statistics }) {
  return (
    <div className="stats-grid">
      <div className="stat-card">
        <div className="stat-card__label">
          <BookOpen size={16} className="text-accent" />
          <span className="stat-card__meta">Изучено</span>
        </div>
        <p className="stat-value">{statistics.cardsStudiedToday}</p>
      </div>

      <div className="stat-card">
        <div className="stat-card__label">
          <Clock size={16} className="text-accent-2" />
          <span className="stat-card__meta">Минут</span>
        </div>
        <p className="stat-value">{statistics.timeSpentToday}</p>
      </div>

      <div className="stat-card">
        <div className="stat-card__label">
          <Flame size={16} className="text-accent-2" />
          <span className="stat-card__meta">Дней</span>
        </div>
        <p className="stat-value">{statistics.currentStreak}</p>
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\dashboard\components\DeckList.tsx
==============================

import React from 'react';
import type { Deck } from '../../../types';
import { DeckCard } from '../../../components/DeckCard';

type Props = {
  decks: Deck[];
  onDeckClick: (deckId: string) => void;
  onEditDeck?: (deckId: string) => void;
};

export function DeckList({ decks, onDeckClick, onEditDeck }: Props) {
  return (
    <div className="p-4 container-centered max-w-390">
      <div className="space-y-3">
        {decks.map((deck) => (
          <DeckCard
            key={deck.deck_id}
            deck={deck}
            onClick={() => onDeckClick(deck.deck_id)}
            onEdit={onEditDeck ? () => onEditDeck(deck.deck_id) : undefined}
          />
        ))}
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\dashboard\components\GroupsBar.tsx
==============================

import React from 'react';
import { Trash2 } from 'lucide-react';
import type { Group } from '../../../types';
import { useGroupsCarousel } from '../useGroupsCarousel';

type Props = {
  groups: Group[];
  activeGroupId: string | null;
  onGroupChange: (id: string) => void;
  onCreateGroup: () => void;
  onDeleteActiveGroup: () => void;
};

export function GroupsBar({
  groups,
  activeGroupId,
  onGroupChange,
  onCreateGroup,
  onDeleteActiveGroup,
}: Props) {
  const { carouselRef, onWheelCarousel, onMouseDown, onMouseMove, onMouseUpOrLeave } =
    useGroupsCarousel();

  const safeGroups = groups ?? [];

  return (
    <div className="groups-section">
      <div className="groups-container">
        <button className="groups-button groups-button-add" onClick={onCreateGroup}>
          +
        </button>

        <div className="groups-carousel-wrapper">
          {safeGroups.length === 0 ? (
            <p className="groups-empty-message">Создайте первую группу</p>
          ) : (
            <div
              ref={carouselRef}
              className="groups-carousel"
              onWheel={onWheelCarousel}
              onMouseDown={onMouseDown}
              onMouseMove={onMouseMove}
              onMouseUp={onMouseUpOrLeave}
              onMouseLeave={onMouseUpOrLeave}
            >
              {safeGroups.map((g) => (
                <button
                  key={g.id}
                  type="button"
                  className={'group-pill' + (g.id === activeGroupId ? ' group-pill--active' : '')}
                  onClick={() => onGroupChange(g.id)}
                >
                  {g.title}
                </button>
              ))}
            </div>
          )}
        </div>

        <button
          className="groups-button groups-button-delete"
          onClick={onDeleteActiveGroup}
          disabled={!activeGroupId}
          title={!activeGroupId ? 'Нет активной группы' : 'Удалить группу'}
        >
          <Trash2 size={18} />
        </button>
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\decks\CreateDeck.tsx
==============================

import React, { useState } from 'react';
import { ApiClient } from '../../api/client';

export function CreateDeck({
  onSave,
  onCancel,
}: {
  onSave: (createdDeckId?: string) => void;
  onCancel: () => void;
}) {
  const [title, setTitle] = useState('');
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const submit = async () => {
    const t = title.trim();
    if (!t) return;

    try {
      setSaving(true);
      setError(null);
      const created = await ApiClient.createDeck({ title: t });
      onSave(created.id);
    } catch (e) {
      setError('Не удалось создать колоду');
    } finally {
      setSaving(false);
    }
  };

  return (
    <div className="min-h-screen bg-dark p-4">
      <div className="container-centered max-w-390">
        <div className="card">
          <h2 className="page__title">Новая колода</h2>

          <label className="field">
            <div className="field__label">Название</div>
            <input
              className="input"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder="Например: Английские слова"
              maxLength={60}
            />
          </label>

          {error && <div className="text-error">{error}</div>}

          <div className="actions">
            <button className="btn-ghost" onClick={onCancel} disabled={saving}>
              Отмена
            </button>
            <button className="btn-primary" onClick={submit} disabled={saving || !title.trim()}>
              {saving ? 'Сохранение…' : 'Создать'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\decks\DecksActionsContainer.tsx
==============================

import React from 'react';

export type DecksActionsApi = {
  onDeckCreated: () => void;
  onDeckSaved: () => void;
};

export function DecksActionsContainer({
  refreshDecks,
  closeCreateDeck,
  closeEditDeck,
  children,
}) {
  const onDeckCreated = () => {
    refreshDecks();
    closeCreateDeck();
  };

  const onDeckSaved = () => {
    refreshDecks();
    closeEditDeck();
  };

  return children({ onDeckCreated, onDeckSaved });
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\decks\DecksFlowContainer.tsx
==============================

import React from 'react';

export type DecksFlowApi = {
  isCreatingDeck: boolean;
  isEditingDeck: boolean;
  editingDeckId: string | null;
  openCreateDeck: () => void;
  closeCreateDeck: () => void;
  openEditDeck: (deckId: string) => void;
  closeEditDeck: () => void;
  clearEditingDeckId: () => void;
};

export function DecksFlowContainer({
  children,
}: {
  children: (api: DecksFlowApi) => React.ReactNode;
}) {
  const [isCreatingDeck, setIsCreatingDeck] = React.useState(false);
  const [isEditingDeck, setIsEditingDeck] = React.useState(false);
  const [editingDeckId, setEditingDeckId] = React.useState<string | null>(null);

  const api: DecksFlowApi = {
    isCreatingDeck,
    isEditingDeck,
    editingDeckId,

    openCreateDeck: () => setIsCreatingDeck(true),
    closeCreateDeck: () => setIsCreatingDeck(false),

    openEditDeck: (deckId: string) => {
      setEditingDeckId(deckId);
      setIsEditingDeck(true);
    },
    closeEditDeck: () => {
        setIsEditingDeck(false);
        setEditingDeckId(null);
    },


    clearEditingDeckId: () => setEditingDeckId(null),
  };

  return <>{children(api)}</>;
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\decks\EditDeck.tsx
==============================

import React, { useEffect, useState } from 'react';
import { ApiClient } from '../../api/client';
import { Button } from '../../components/Button/Button';
import { getErrorMessage } from '../../utils/errorMessage';

export function EditDeck({
  deckId,
  onCancel,
  onSaved,
}: {
  deckId: string;
  onCancel: () => void;
  onSaved: () => void;
}) {
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isPublic, setIsPublic] = useState(false);

  useEffect(() => {
    (async () => {
      setLoading(true);
      try {
        const cards_with_deck = await ApiClient.getDeckWithCards(deckId);
        const deck = cards_with_deck.deck;
        setTitle(deck.title ?? deck.name ?? '');
        setDescription(deck.description ?? '');
        setIsPublic(deck.is_public ?? false);
      } catch (e: unknown) {
        console.error(e);
        setError('Не удалось загрузить колоду: ' + getErrorMessage(e));
      } finally {
        setLoading(false);
      }
    })();
  }, [deckId]);

  const submit = async () => {
    const t = title.trim();
    if (!t) return;

    try {
      setSaving(true);
      setError(null);
      await ApiClient.updateDeck(deckId, { title: t, description: description || null, is_public: isPublic });
      onSaved();
    } catch (e) {
      setError('Не удалось обновить колоду');
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return <div className="min-h-screen bg-dark flex items-center justify-center">Загрузка…</div>;
  }

  return (
    <div className="min-h-screen bg-dark p-4">
      <div className="container-centered max-w-390">
        <div className="card">
          <h2 className="page__title">Редактировать колоду</h2>

          <label className="field">
            <div className="field__label">Название</div>
            <input
              className="input"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder="Название колоды"
              maxLength={60}
            />
          </label>
            <label className="form-row">
            <input
                type="checkbox"
                checked={isPublic}
                onChange={(e) => setIsPublic(e.target.checked)}
            />
            <span style={{ marginLeft: 8 }}>Сделать колоду публичной</span>
            </label>
          <label className="field">
            <div className="field__label">Описание</div>
            <textarea
              className="input"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Краткое описание (опционально)"
            />
          </label>

          {error && <div className="text-error">{error}</div>}

          <div className="actions">
            <button className="btn-ghost" onClick={onCancel} disabled={saving}>
              Отмена
            </button>
            <button className="btn-primary" onClick={submit} disabled={saving || !title.trim()}>
              {saving ? 'Сохранение…' : 'Сохранить'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\decks\index.ts
==============================

export { CreateDeck } from './CreateDeck';
export { EditDeck } from './EditDeck';
export { AddDeck } from './add/AddDeck';
export { DecksActionsContainer } from './DecksActionsContainer';
export { DecksFlowContainer } from './DecksFlowContainer';
export type { DecksActionsApi } from './DecksActionsContainer';
export type { DecksFlowApi } from './DecksFlowContainer';



==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\decks\add\AddDeck.tsx
==============================

// src/screens/AddDeck/AddDeck.tsx
import { useState, useEffect, useMemo } from 'react';
import { Search, Plus, Trash2 } from 'lucide-react';
import { Button } from '../../../components/Button/Button';
import { ApiClient } from '../../../api/client';
import { PublicDeckSummary } from '../../../types';
import { useAuth } from '../../../auth/AuthContext';
import './AddDeck.css';

type Props = {
  groupId: string;
  initialGroupDeckIds?: string[];
  onClose: () => void;
  onChanged?: (deckId: string, action: 'added' | 'removed') => void;
};

 export const AddDeck = ({ groupId, initialGroupDeckIds = [], onClose, onChanged }: Props) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');

  const [decks, setDecks] = useState<PublicDeckSummary[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const limit = 20;
  const [hasMore, setHasMore] = useState(true);

  const [groupDeckIds, setGroupDeckIds] = useState<Set<string>>(
    () => new Set(initialGroupDeckIds),
  );

  const { currentUser } = useAuth();

  const filteredDecks = useMemo(() => (
    decks.filter(d => d.owner_id !== currentUser?.id)
  ), [decks, currentUser]);

  // если родитель может менять initialGroupDeckIds (например, после рефреша группы)
  useEffect(() => {
    setGroupDeckIds(new Set(initialGroupDeckIds));
  }, [initialGroupDeckIds]);

  // debounce
  useEffect(() => {
    const t = setTimeout(() => {
      setDebouncedQuery(searchQuery);
      setHasMore(true);
    }, 400);
    return () => clearTimeout(t);
  }, [searchQuery]);

  // загрузка
  useEffect(() => {
    let cancelled = false;

    const run = async () => {
      try {
        setLoading(true);
        setError(null);

        const data = await ApiClient.searchPublicDecks({
          q: debouncedQuery,
          limit,
          offset: 0,
        });

        if (cancelled) return;
        setDecks(data);
        setHasMore(data.length === limit);
      } catch (e: any) {
        if (cancelled) return;
        setError(e?.message ?? 'Ошибка загрузки колод');
      } finally {
        if (!cancelled) setLoading(false);
      }
    };

    run();
    return () => {
      cancelled = true;
    };
  }, [debouncedQuery]);

    const loadMore = async () => {
        if (loading || !hasMore) return;

        try {
            setLoading(true);
            setError(null);

            const currentOffset = decks.length; // ключевой фикс

            const data = await ApiClient.searchPublicDecks({
            q: debouncedQuery,
            limit,
            offset: currentOffset,
            });

            setDecks(prev => [...prev, ...data]);
            setHasMore(data.length === limit);
        } catch (e: any) {
            setError(e?.message ?? 'Ошибка загрузки колод');
        } finally {
            setLoading(false);
        }
    };

  const handleAdd = async (deckId: string) => {
    try {
      await ApiClient.addDeckToGroup(groupId, deckId);
      setGroupDeckIds(prev => new Set(prev).add(deckId));
      onChanged?.(deckId, 'added');
    } catch (e: any) {
      alert(`Ошибка: ${e?.message ?? 'не удалось добавить колоду в группу'}`);
    }
  };

  const handleRemove = async (deckId: string) => {
    try {
      await ApiClient.removeDeckFromGroup(groupId, deckId);
      setGroupDeckIds(prev => {
        const next = new Set(prev);
        next.delete(deckId);
        return next;
      });
      onChanged?.(deckId, 'removed');
    } catch (e: any) {
      alert(`Ошибка: ${e?.message ?? 'не удалось удалить колоду из группы'}`);
    }
  };

  return (
    <div className="add-deck-container">
      <div className="add-deck-header">
        <h2>Колоды группы</h2>
        <Button onClick={onClose} variant="secondary" size="small">
          Закрыть
        </Button>
      </div>

      <div className="search-container">
        <Search className="search-icon" size={20} />
        <input
          type="text"
          placeholder="Поиск публичных колод..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="search-input"
        />
      </div>

      {error && <div className="error-message">{error}</div>}

      <div className="decks-list">
        {loading && decks.length === 0 ? (
          <div className="loading">Загрузка...</div>
        ) : decks.length === 0 ? (
          <div className="no-results">Колоды не найдены</div>
        ) : (
          <>
            {filteredDecks.map((deck) => {
              const inGroup = groupDeckIds.has(deck.deck_id);

              return (
                <div key={deck.deck_id} className="deck-card">
                  <div className="deck-info">
                    <h3 className="deck-title">{deck.title}</h3>
                    {deck.description ? (
                      <div className="deck-meta">
                        <span className="deck-author">{deck.description}</span>
                      </div>
                    ) : null}
                  </div>

                  {!inGroup ? (
                    <Button
                      onClick={() => handleAdd(deck.deck_id)}
                      variant="primary"
                      size="small"
                    >
                      <Plus size={16} />
                      Добавить
                    </Button>
                  ) : (
                    <Button
                      onClick={() => handleRemove(deck.deck_id)}
                      variant="secondary"
                      size="small"
                    >
                      <Trash2 size={16} />
                      Удалить
                    </Button>
                  )}
                </div>
              );
            })}

            {hasMore && (
              <Button
                onClick={loadMore}
                variant="secondary"
                size="medium"
                fullWidth
                disabled={loading}
              >
                {loading ? 'Загрузка...' : 'Загрузить ещё'}
              </Button>
            )}
          </>
        )}
      </div>
    </div>
  );
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\decks\details\DeckDetailsScreen.tsx
==============================

import React, { useMemo, useState } from 'react';
import type { StudyMode } from '../../../types';
import { loadSession, type PersistedSession } from '../../../utils/sessionStore';

type Props = {
  deckId: string;
  onBack: () => void;
  onStart: (mode: StudyMode, limit?: number) => void;
  onResume: (saved: PersistedSession) => void;
  clearSavedSession: () => void; // без deckId
};

export function DeckDetailsScreen(props: Props) {
  const [limit, setLimit] = useState<number>(20);
  const [sessionVersion, setSessionVersion] = useState(0);

  const key = `deck:${props.deckId}` as const;

  const saved = useMemo(() => loadSession(key), [key, sessionVersion]);
  const hasSaved = !!saved && (saved.deckCards?.length ?? 0) > 0;

  const limitClamped = useMemo(() => {
    const n = Number(limit);
    if (!Number.isFinite(n)) return 20;
    return Math.max(1, Math.min(200, Math.trunc(n)));
  }, [limit]);

  const start = (mode: StudyMode) => {
    if (hasSaved) {
      props.clearSavedSession();
      setSessionVersion((v) => v + 1);          // чтобы UI перестал показывать saved
    }

    if (mode === 'new_random' || mode === 'new_ordered') props.onStart(mode, limitClamped);
    else props.onStart(mode);
  };


  return (
    <div className="min-h-screen bg-dark pb-24">
      <div className="page__header px-4 pt-12 pb-6">
        <div className="page__header-inner">
          <button className="btn-ghost" onClick={props.onBack} type="button">
            Назад
          </button>
          <h1 className="page__title">Колода</h1>
          <div style={{ color: '#9CA3AF', fontSize: 12 }}>id: {props.deckId}</div>
        </div>
      </div>

      <div className="container-centered max-w-390">
        <div className="actionsStackstudy" style={{ display: 'grid', gap: 20 }}>
          {hasSaved && (
            <div className="card">
              <p className="text-[#E8EAF0]">Есть незавершённая сессия</p>
              <p className="text-[#9CA3AF]">
                Карточка {((saved!.currentIndex ?? 0) + 1)} из {saved!.deckCards.length}
              </p>

              <div style={{ display: 'flex', gap: 12 }}>
                <button className="btn-primary" onClick={() => props.onResume(saved!)}>
                  Продолжить
                </button>
              </div>
            </div>
          )}
          <button className="btn btn--primary btn--full" onClick={() => start('random')}>
            Случайно
          </button>

          <button className="btn btn--secondary btn--full" onClick={() => start('ordered')}>
            По порядку
          </button>

          <button className="btn btn--secondary btn--full" onClick={() => start('new_random')}>
            Новые случайно
          </button>

          <button className="btn btn--secondary btn--full" onClick={() => start('new_ordered')}>
            Новые по порядку
          </button>

          {/* limit field */}
          <div className="card" style={{ marginTop: 8 }}>
            <div style={{ color: '#E8EAF0', fontSize: 14, marginBottom: 6 }}>
              Кол-во карточек для “Новые …”
            </div>

            <input
              className="input"
              type="number"
              min={1}
              max={200}
              value={String(limit)}
              onChange={(e) => setLimit(Number(e.target.value))}
              placeholder="Напр. 20"
            />

            <div style={{ color: '#9CA3AF', fontSize: 12, marginTop: 6 }}>
              Будет использовано: {limitClamped}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\groups\CreateGroup.tsx
==============================

import React, { useState } from 'react';
import { ApiClient } from '../../api/client';

export function CreateGroup({
  onSave,
  onCancel,
}: {
  onSave: (createdGroupId?: string) => void;
  onCancel: () => void;
}) {
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const submit = async () => {
    const t = title.trim();
    if (!t) return;

    try {
      setSaving(true);
      setError(null);

      const created = await ApiClient.createGroup({
        title: t,
        description: description.trim() || null,
        parent_id: null, // если позже добавишь выбор родителя — подставишь сюда
      });

      // created.id должен быть user_group_id (или нормализованный id)
      onSave(created?.id);
    } catch (e) {
      setError('Не удалось создать группу');
    } finally {
      setSaving(false);
    }
  };

  return (
    <div className="min-h-screen bg-dark p-4">
      <div className="container-centered max-w-390">
        <div className="card">
          <h2 className="page__title">Новая группа</h2>

          <label className="field">
            <div className="field__label">Название</div>
            <input
              className="input"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder="Например: Мои колоды"
              maxLength={60}
              disabled={saving}
            />
          </label>

          <label className="field">
            <div className="field__label">Описание</div>
            <textarea
              className="input input--textarea"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Необязательно"
              rows={3}
              disabled={saving}
            />
          </label>

          {error && <div className="text-error">{error}</div>}

          <div className="actions">
            <button className="btn-ghost" onClick={onCancel} disabled={saving}>
              Отмена
            </button>
            <button
              className="btn-primary"
              onClick={submit}
              disabled={saving || !title.trim()}
            >
              {saving ? 'Сохранение…' : 'Создать'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\home\HomeTab.tsx
==============================

import React from 'react';
import type { Deck, Group, Statistics } from '../../types';
import type { PersistedSession } from '../../utils/sessionStore';
import { DashboardContainer } from '../dashboard/DashboardContainer';

type Props = {
  statistics: Statistics;
  decks: Deck[];
  groups: Group[];
  activeGroupId: string | null;

  resumeCandidate: PersistedSession | null;
  onResume: () => void;
  onDiscardResume: () => void;

  onGroupChange: (groupId: string | null) => void;
  onCreateGroup: () => void;
  onDeleteActiveGroup: () => void;

  onStartStudy: () => void;
  onDeckClick: (deckId: string) => void;
  onOpenEditDeck: (deckId: string) => void;
  onAddDeck: () => void;
};

export function HomeTab(props: Props) {
  return (
    <DashboardContainer
      statistics={props.statistics}
      decks={props.decks}
      groups={props.groups}
      activeGroupId={props.activeGroupId}
      resumeCandidate={props.resumeCandidate}
      onResume={props.onResume}
      onDiscardResume={props.onDiscardResume}
      onGroupChange={(id) => props.onGroupChange(id)}
      onCreateGroup={props.onCreateGroup}
      onDeleteActiveGroup={props.onDeleteActiveGroup}
      onStartStudy={props.onStartStudy}
      onDeckClick={props.onDeckClick}
      onOpenEditDeck={props.onOpenEditDeck}
      onAddDeck={props.onAddDeck}
    />
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\home\HomeTabContainer.tsx
==============================

import React from 'react';
import type { PersistedSession } from '../../utils/sessionStore';
import type { Deck, Group, StudyMode, Statistics } from '../../types';

import { HomeTab } from './HomeTab';
import { CreateGroup } from '../groups/CreateGroup';
import { AddDeck } from '../decks/add/AddDeck';
import { DeckDetailsScreen } from '../decks/details/DeckDetailsScreen';

type Props = {
  // данные home
  statistics: Statistics;
  decks: Deck[];
  groups: Group[];
  activeGroupId: string | null;
  setActiveGroupId: (id: string | null) => void;

  // из твоего useGroupsDecksController
  refreshGroups: () => Promise<void>;
  refreshDecks: () => Promise<void>;
  currentGroupDeckIds: string[];
  onDeleteActiveGroup: () => void;

  // resume
  resumeCandidate: PersistedSession | null;
  onResume: () => void;
  onDiscardResume: () => void;

  // действия, которые запускают study (остаются в App)
  onStartReviewStudy: () => Promise<void>;
  onStartDeckStudy: (deckId: string, mode: StudyMode, limit?: number) => Promise<void>;
  onResumeDeckSession: (saved: PersistedSession) => void;
  onRestartDeckSession: (deckId: string) => void;

  // пока оставляем редактирование колоды глобальным
  onOpenEditDeck: (deckId: string) => void;
};

type HomeView =
  | { kind: 'dashboard' }
  | { kind: 'createGroup' }
  | { kind: 'addDeck' }
  | { kind: 'deckDetails'; deckId: string };

export function HomeTabContainer(props: Props) {
    const [view, setView] = React.useState<HomeView>({ kind: 'dashboard' });
    React.useEffect(() => {
        if (view.kind === 'addDeck' && !props.activeGroupId) {
            setView({ kind: 'dashboard' });
        }
    }, [view.kind, props.activeGroupId]);

  // --- экраны home ---
  if (view.kind === 'createGroup') {
    return (
      <CreateGroup
        onCancel={() => setView({ kind: 'dashboard' })}
        onSave={async (createdGroupId) => {
          await props.refreshGroups();
          if (createdGroupId) props.setActiveGroupId(createdGroupId);
          setView({ kind: 'dashboard' });
        }}
      />
    );
  }

  if (view.kind === 'addDeck') {
    if (!props.activeGroupId) return null;
    return (
      <AddDeck
        groupId={props.activeGroupId}
        initialGroupDeckIds={props.currentGroupDeckIds}
        onClose={() => setView({ kind: 'dashboard' })}
        onChanged={() => props.refreshDecks()}
      />
    );
  }

    if (view.kind === 'deckDetails') {
    const deckId = view.deckId;

    return (
        <DeckDetailsScreen
        deckId={deckId}
        onBack={() => setView({ kind: 'dashboard' })}
        onStart={(mode, limit) => props.onStartDeckStudy(deckId, mode, limit)}
        onResume={(saved) => { setView({ kind: 'dashboard' }); props.onResumeDeckSession(saved); }}
        clearSavedSession={() => props.onRestartDeckSession(deckId)}
        />
    );
    }


  // --- обычный home (dashboard) ---
  return (
    <HomeTab
        statistics={props.statistics}
        decks={props.decks}
        groups={props.groups}
        activeGroupId={props.activeGroupId}
        resumeCandidate={props.resumeCandidate}
        onResume={props.onResume}
        onDiscardResume={props.onDiscardResume}
        onGroupChange={props.setActiveGroupId}
        onCreateGroup={() => setView({ kind: 'createGroup' })}
        onDeleteActiveGroup={props.onDeleteActiveGroup}
        onStartStudy={props.onStartReviewStudy}
        onDeckClick={(deckId) => setView({ kind: 'deckDetails', deckId })}
        onOpenEditDeck={props.onOpenEditDeck}
        onAddDeck={() => {
        if (!props.activeGroupId) return;
            setView({ kind: 'addDeck' });
        }}
    />
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\main\index.ts
==============================

export { MainShellContainer } from './MainShellContainer';




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\main\mainShell.types.ts
==============================

import React from 'react';

export type MainTab = 'home' | 'study' | 'stats' | 'profile';

export type MainShellViewProps = {
  content: React.ReactNode;
  hideBottomNav: boolean;
  activeTab: MainTab;
  onTabChange: (tab: MainTab) => void;
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\main\MainShellContainer.tsx
==============================

// src/screens/main/MainShellContainer.tsx
import React, { useState } from 'react';

import { useStatistics } from '../../hooks';
import { useGroupsDecksController } from '../../hooks/useGroupsDecksController';

import { StudyFlowStateContainer } from '../study/StudyFlowStateContainer';
import { MainShellView } from './MainShellView';
import type { MainTab } from './mainShell.types';

import { useIsPWA } from '../../app/pwa/useIsPWA';
import { useRegisterServiceWorker } from '../../app/pwa/useRegisterServiceWorker';

import { MnemonicRootSwitch } from './MnemonicRootSwitch';

import { CardsActionsContainer, CardsFlowContainer } from '../cards';
import { DecksActionsContainer, DecksFlowContainer } from '../decks';
import { DecksFlowApi } from '../decks/DecksFlowContainer';
import { DecksActionsApi } from '../decks/DecksActionsContainer';
import { CardsFlowApi } from '../cards/CardsFlowContainer';
import { CardsActionsApi } from '../cards/CardsActionsContainer';

export function MainShellContainer() {
  const {
    groups,
    activeGroupId,
    setActiveGroupId,
    decks,
    decksLoading,
    decksError,
    refreshDecks,
    refreshGroups,
    deleteActiveGroup,
    currentGroupDeckIds,
  } = useGroupsDecksController();

  const { statistics, loading: statsLoading, error: statsError, refresh: refreshStats } =
    useStatistics();

  const dashboardStats =
    statistics ?? {
      cardsStudiedToday: 0,
      timeSpentToday: 0,
      currentStreak: 0,
      totalCards: 0,
      weeklyActivity: [0, 0, 0, 0, 0, 0, 0],
      achievements: [],
    };

  const [activeTab, setActiveTab] = useState<MainTab>('home');

  useRegisterServiceWorker();
  const isPWA = useIsPWA();

  return (
    <StudyFlowStateContainer onExitToHome={() => setActiveTab('home')} onRated={refreshStats}>
      {(study) => (
        <DecksFlowContainer>
          {(decksFlow: DecksFlowApi) => (
            <DecksActionsContainer
              refreshDecks={refreshDecks}
              closeCreateDeck={decksFlow.closeCreateDeck}
              closeEditDeck={decksFlow.closeEditDeck}
            >
              {(decksApi: DecksActionsApi) => (
                <CardsFlowContainer>
                  {(cardsFlow: CardsFlowApi) => {
                    const hideBottomNav =
                      study.isStudying ||
                      decksLoading ||
                      statsLoading ||
                      Boolean(statsError) ||
                      cardsFlow.isCreatingCard ||
                      cardsFlow.isEditingCard ||
                      decksFlow.isCreatingDeck ||
                      decksFlow.isEditingDeck;

                    return (
                      <CardsActionsContainer
                        refreshDecks={refreshDecks}
                        refreshStats={refreshStats}
                        closeCreateCard={cardsFlow.closeCreateCard}
                        closeEditCard={cardsFlow.closeEditCard}
                      >
                        {(cardsApi: CardsActionsApi) => (
                          <MainShellView
                            hideBottomNav={hideBottomNav}
                            activeTab={activeTab}
                            onTabChange={setActiveTab}
                            content={
                              <MnemonicRootSwitch
                                study={study}
                                activeTab={activeTab}
                                isPWA={isPWA}
                                cards={{ flow: cardsFlow, actions: cardsApi }}
                                decks={{ flow: decksFlow, actions: decksApi }}
                                data={{
                                  decks,
                                  groups,
                                  activeGroupId,
                                  currentGroupDeckIds,
                                  statistics,
                                  dashboardStats,
                                }}
                                status={{
                                  decksLoading,
                                  statsLoading,
                                  decksError,
                                  statsError,
                                }}
                                refresh={{
                                  refreshDecks,
                                  refreshGroups,
                                  refreshStats,
                                }}
                                groupsActions={{
                                  setActiveGroupId,
                                  deleteActiveGroup,
                                }}
                              />
                            }
                          />
                        )}
                      </CardsActionsContainer>
                    );
                  }}
                </CardsFlowContainer>
              )}
            </DecksActionsContainer>
          )}
        </DecksFlowContainer>
      )}
    </StudyFlowStateContainer>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\main\MainShellView.tsx
==============================

import React from 'react';

import { BottomNav } from '../../components/BottomNav';
import { InstallPrompt } from '../../components/InstallPrompt';
import { OfflineStatus } from '../../app/overlays/OfflineStatus';
import { PWAUpdatePrompt } from '../../app/overlays/PWAUpdatePrompt';

import type { MainShellViewProps } from './mainShell.types';

export function MainShellView(props: MainShellViewProps) {
  return (
    <div className="relative">
      <PWAUpdatePrompt />
      <OfflineStatus />

      {props.content}

      {!props.hideBottomNav && (
        <BottomNav activeTab={props.activeTab} onTabChange={props.onTabChange} />
      )}
      <InstallPrompt />
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\main\MnemonicRootSwitch.tsx
==============================

import React from 'react';

import { CreateCard, EditCardFlow } from '../cards';
import { CreateDeck, EditDeck } from '../decks';
import { Statistics } from '../stats';

import { HomeTabContainer } from '../home/HomeTabContainer';
import { ProfileContainer } from '../profile/ProfileContainer';

import type { MnemonicRootSwitchProps } from './mnemonicRootSwitch.types';

export function MnemonicRootSwitch(props: MnemonicRootSwitchProps) {
  // loading
  if (props.status.decksLoading || props.status.statsLoading) {
    return (
      <div className="min-h-screen bg-dark flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-accent mx-auto mb-4"></div>
          <p className="text-[#9CA3AF]">Загрузка данных...</p>
        </div>
      </div>
    );
  }

  // error
  if (props.status.decksError || props.status.statsError) {
    return (
      <div className="min-h-screen bg-dark flex items-center justify-center p-4">
        <div className="card text-center">
          <div className="text-4xl mb-4">⚠️</div>
          <h2 className="text-[#E8EAF0] mb-2">Ошибка загрузки</h2>
          <p className="text-[#9CA3AF] mb-4">
            {String(props.status.decksError ?? props.status.statsError)}
          </p>
          <button
            onClick={() => {
              props.refresh.refreshDecks();
              props.refresh.refreshStats();
            }}
            className="btn-primary"
          >
            Попробовать снова
          </button>
        </div>
      </div>
    );
  }

  // flows
  if (props.cards.flow.isCreatingCard) {
    return (
      <CreateCard
        decks={props.data.decks}
        onSave={props.cards.actions.onCreateCardSave}
        onSaveMany={props.cards.actions.onCreateCardSaveMany}
        onCancel={props.cards.flow.closeCreateCard}
      />
    );
  }

  if (props.decks.flow.isCreatingDeck) {
    return (
      <CreateDeck
        onCancel={props.decks.flow.closeCreateDeck}
        onSave={(createdDeckId?: string) => {
          // refresh + close create deck modal/screen
          props.decks.actions.onDeckCreated();

          // опционально: сразу открыть экран редактирования только что созданной колоды
          if (createdDeckId) {
            props.decks.flow.openEditDeck(createdDeckId);
          }
        }}
      />
    );
  }

  if (props.decks.flow.isEditingDeck && props.decks.flow.editingDeckId) {
    return (
      <EditDeck
        deckId={props.decks.flow.editingDeckId}
        onCancel={props.decks.flow.closeEditDeck}
        onSaved={props.decks.actions.onDeckSaved}
      />
    );
  }

  if (props.cards.flow.isEditingCard) {
    return (
      <EditCardFlow
        decks={props.data.decks}
        onCancel={props.cards.flow.closeEditCard}
        onDone={props.cards.actions.onEditCardDone}
        onEditDeck={(deckId: string) => {
          props.decks.flow.openEditDeck(deckId);
        }}
      />
    );
  }

  // tabs
  return (
    <>
      {props.isPWA && (
        <div className="fixed top-4 left-4 z-30">
          <div className="pwa-badge">PWA</div>
        </div>
      )}

      {props.activeTab === 'home' && (
        <HomeTabContainer
          statistics={props.data.dashboardStats}
          decks={props.data.decks}
          groups={props.data.groups}
          activeGroupId={props.data.activeGroupId}
          setActiveGroupId={props.groupsActions.setActiveGroupId}
          refreshGroups={props.refresh.refreshGroups}
          refreshDecks={props.refresh.refreshDecks}
          currentGroupDeckIds={props.data.currentGroupDeckIds}
          onDeleteActiveGroup={props.groupsActions.deleteActiveGroup}
          resumeCandidate={props.study.resumeCandidate}
          onResume={props.study.onResume}
          onDiscardResume={props.study.onDiscardResume}
          onStartReviewStudy={props.study.onStartReviewStudy}
          onStartDeckStudy={props.study.onStartDeckStudy}
          onResumeDeckSession={props.study.onResumeDeckSession}
          onRestartDeckSession={props.study.onRestartDeckSession}
          onOpenEditDeck={props.decks.flow.openEditDeck}
        />
      )}

      {props.activeTab === 'study' && (
        <div className="min-h-screen bg-dark pb-24">
          <header className="page__header">
            <div className="page__header-inner">
              <h1 className="page__title">Обучение</h1>
            </div>
          </header>

          <main className="container-centered max-w-390 py-6">
            <div className="text-center py-12">
              <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>📖</div>
              <h2 style={{ marginBottom: '1rem', color: '#E8EAF0' }}>Создайте свою первую карточку</h2>
              <p style={{ color: '#9CA3AF', marginBottom: '1.5rem' }}>
                Начните изучение с создания карточек
              </p>

              <div className="actionsStack__study">
                <button onClick={props.cards.flow.openCreateCard} className="btn-primary">
                  Создать карточку
                </button>

                <button onClick={props.decks.flow.openCreateDeck} className="btn-primary">
                  Создать колоду
                </button>

                <button onClick={props.cards.flow.openEditCard} className="btn-primary">
                  Редактировать карточки
                </button>
              </div>

              {!props.isPWA && (
                <div className="mt-8 card">
                  <p style={{ color: '#9CA3AF', marginBottom: '0.5rem' }}>
                    💡 Установите приложение для работы офлайн
                  </p>
                  <p style={{ color: '#6B7280', fontSize: '0.75rem' }}>
                    Нажмите "Установить" в меню браузера
                  </p>
                </div>
              )}
            </div>
          </main>
        </div>
      )}

      {props.activeTab === 'stats' && props.data.statistics && (
        <Statistics statistics={props.data.statistics} decks={props.data.decks} />
      )}

      {props.activeTab === 'profile' && <ProfileContainer isPWA={props.isPWA} />}
    </>
  );
}



==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\main\mnemonicRootSwitch.types.ts
==============================

import type { MainTab } from './mainShell.types';
import type { CardsFlowApi, CardsActionsApi } from '../cards';
import type { DecksFlowApi, DecksActionsApi } from '../decks';


export type MnemonicRootSwitchProps = {
  study: any; // оставь как у тебя тип study
  activeTab: MainTab;
  isPWA: boolean;

  cards: {
    flow: CardsFlowApi;
    actions: CardsActionsApi;
  };

  decks: {
    flow: DecksFlowApi;
    actions: DecksActionsApi;
  };

  data: {
    decks: any[];
    groups: any[];
    activeGroupId: string | null;
    currentGroupDeckIds: string[];
    statistics: any;
    dashboardStats: any;
  };

  status: {
    decksLoading: boolean;
    statsLoading: boolean;
    decksError: any;
    statsError: any;
  };

    refresh: {
        refreshGroups: () => Promise<void>;
        refreshDecks: () => Promise<void>;
        refreshStats: () => Promise<void>;
    };

    groupsActions: {
        setActiveGroupId: (id: string | null) => void;
        deleteActiveGroup: () => Promise<void>;
    };
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\Onboarding\Onboarding.tsx
==============================

import React, { useState } from 'react';
import { Button } from '../../components/Button/Button';
import { LevelIndicator } from '../../components/LevelIndicator';
import { motion, AnimatePresence } from 'motion/react';

interface OnboardingProps {
  onComplete: () => void;
}

export function Onboarding({ onComplete }: OnboardingProps) {
  const [currentStep, setCurrentStep] = useState(0);

  const steps = [
    {
      title: 'Добро пожаловать в MnemonicFlow',
      description: 'Учитесь эффективно с карточками, которые растут вместе с вами',
      image: '📚',
    },
    {
      title: 'Уровни мастерства',
      description: 'Каждая карточка проходит путь от знакомства до полного освоения',
      image: '🎯',
    },
    {
      title: 'Начните прямо сейчас',
      description: 'Создайте свою или выберите первую колоду и начните путь к знаниям',
      image: '🚀',
    },
  ];

  const handleNext = () => {
    if (currentStep < steps.length - 1) {
      setCurrentStep(currentStep + 1);
    } else {
      onComplete();
    }
  };

  return (
    <div className="min-h-screen bg-dark layout-vertical-between">
      {/* Контент */}
      <div className="flex-1 center-vertical px-4">
  <div className="max-w-390 w-full">
          <AnimatePresence mode="wait">
            <motion.div
              key={currentStep}
              initial={{ opacity: 0, x: 20 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: -20 }}
              transition={{ duration: 0.3 }}
              className="text-center"
            >
              {/* Illustration */}

              <div className="onboarding__image mb-8">{steps[currentStep].image}</div>

              {/* Title */}
              <h1 className="onboarding__title mb-4">{steps[currentStep].title}</h1>

              {/* Description */}
              <p className="onboarding__desc mb-8">{steps[currentStep].description}</p>

              {/* Level Demo (только на шаге 1) */}
              {currentStep === 1 && (
                <div className="onboarding__demo mb-8">
                  <div className="space-y-4">
                    {[0, 1, 2, 3].map((level) => (
                      <div key={level} className="onboarding__level-row">
                        <span className="text-sm">Уровень {level}</span>
                        <LevelIndicator currentLevel={level as 0 | 1 | 2 | 3} size="medium" />
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </motion.div>
          </AnimatePresence>
        </div>
      </div>

  <div className="px-4 pb-8">
    <div className="container-centered">
      <div className="dots">
        {steps.map((_, index) => (
          <div key={index} className={`dot ${index === currentStep ? 'dot--active' : ''}`} />
        ))}
      </div>

      <div className="mt-4">
        <Button onClick={handleNext} variant="primary" size="large" fullWidth>
          {currentStep < steps.length - 1 ? 'Далее' : 'Начать'}
        </Button>
      </div>
    </div>
  </div>
</div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\profile\profile.types.ts
==============================

export type ApiHealth = 'healthy' | 'unhealthy' | 'checking';

export type ProfileViewProps = {
  apiHealth: ApiHealth;
  isPWA: boolean;

  // пока захардкожено как было, но уже через props
  initials: string;
  name: string;
  email: string;
  version: string;
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\profile\ProfileContainer.tsx
==============================

import React, { useEffect, useState } from 'react';

import { ApiClient } from '../../api/client';
import { ProfileView } from './ProfileView';
import type { ApiHealth } from './profile.types';

type ProfileContainerProps = {
  isPWA: boolean;
};

export function ProfileContainer(props: ProfileContainerProps) {
  const [apiHealth, setApiHealth] = useState<ApiHealth>('checking');

  useEffect(() => {
    const checkApiHealth = async () => {
      try {
        await ApiClient.healthCheck();
        setApiHealth('healthy');
      } catch (error) {
        setApiHealth('unhealthy');
        console.warn('API is unavailable, using fallback data');
      }
    };

    checkApiHealth();
  }, []);

  return (
    <ProfileView
      apiHealth={apiHealth}
      isPWA={props.isPWA}
      initials="У"
      name="АБД"
      email="user@example.com"
      version="1.0.0"
    />
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\profile\ProfileView.tsx
==============================

import React from 'react';
import type { ProfileViewProps } from './profile.types';

export function ProfileView(props: ProfileViewProps) {
  const { apiHealth, isPWA } = props;

  return (
    <div className="min-h-screen bg-dark pb-24">
      <div className="page__header px-4 pt-12 pb-6">
        <div className="page__header-inner">
          <h1 className="page__title">Профиль</h1>
        </div>
      </div>

      <div className="p-4 container-centered max-w-390">
        <div className="card card--center">
          <div className="avatar avatar--xl avatar--accent">{props.initials}</div>
          <h2 className="mb-2 text-[#E8EAF0]">{props.name}</h2>
          <p className="text-[#9CA3AF]">{props.email}</p>

          <div className="mt-6 pt-6 border-t border-[#2D3548]">
            <h3 className="text-sm font-medium text-[#E8EAF0] mb-3">Настройки приложения</h3>
            <div className="space-y-3">
              <div className="flex justify-between items-center">
                <span className="text-sm text-[#9CA3AF]">API Статус</span>
                <span className={`text-sm ${apiHealth === 'healthy' ? 'text-green-500' : 'text-red-500'}`}>
                  {apiHealth === 'healthy' ? '✓ Работает' : '✗ Ошибка'}
                </span>
              </div>

              <div className="flex justify-between items-center">
                <span className="text-sm text-[#9CA3AF]">Версия</span>
                <span className="text-sm text-[#E8EAF0]">{props.version}</span>
              </div>

              <div className="flex justify-between items-center">
                <span className="text-sm text-[#9CA3AF]">Режим</span>
                <span className="text-sm text-accent">
                  {isPWA ? 'Установлено как PWA' : 'Веб-версия'}
                </span>
              </div>

              <div className="flex justify-between items-center">
                <span className="text-sm text-[#9CA3AF]">Офлайн доступ</span>
                <span className="text-sm text-[#38A169]">
                  {isPWA ? 'Доступно' : 'Требуется установка'}
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\stats\index.ts
==============================

export { Statistics } from './Statistics';




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\stats\Statistics.tsx
==============================

import React from 'react';
import { Statistics as StatsType, Deck } from '../../types';
import { ProgressBar } from '../../components/ProgressBar';
import { Trophy, Target, Zap } from 'lucide-react';

interface StatisticsProps {
  statistics: StatsType;
  decks: Deck[];
}

export function Statistics({ statistics, decks }: StatisticsProps) {
  const totalProgress = decks.reduce((acc, deck) => acc + deck.progress, 0) / decks.length;
  
  return (
    <div className="stats-page">
      {/* Header */}
      <div className="page__header px-4 pt-12 pb-6">
  <div className="page__header-inner">
          <h1 className="page__title mb-6">Статистика</h1>
          
          {/* Overall Progress Circle */}
          <div className="stats__progress-wrap">
            <div className="stats__progress-circle">
              <svg className="stats__svg">
                <circle
                  cx="80"
                  cy="80"
                  r="70"
                  stroke="#E5E7EB"
                  strokeWidth="12"
                  fill="none"
                />
                <circle
                  cx="80"
                  cy="80"
                  r="70"
                  stroke="#FF9A76"
                  strokeWidth="12"
                  fill="none"
                  strokeDasharray={`${2 * Math.PI * 70}`}
                  strokeDashoffset={`${2 * Math.PI * 70 * (1 - totalProgress / 100)}`}
                  strokeLinecap="round"
                  className="transition-all duration-500"
                />
              </svg>
              <div className="stats__progress-center">
                <div className="text-center">
                  <div className="stats__progress-value">{Math.round(totalProgress)}%</div>
                  <div className="stats__progress-label">Общий прогресс</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
  <div className="p-4 py-6 container-centered stats__content">
        {/* Weekly Activity */}
        <div className="card">
          <h3 className="mb-4">Активность за неделю</h3>
          <div className="stats__bars">
            {['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'].map((day, index) => {
              const value = statistics.weeklyActivity[index] || 0;
              const maxValue = Math.max(...statistics.weeklyActivity, 1);
              const height = (value / maxValue) * 100;
              
              return (
                <div key={day} className="stats__bar-col">
                  <div className="stats__bar-track" style={{ height: '100px' }}>
                    <div
                      className="stats__bar-fill"
                      style={{ height: `${height}%` }}
                    />
                  </div>
                  <span className="stats__bar-label">{day}</span>
                </div>
              );
            })}
          </div>
        </div>
        
        {/* Decks Progress */}
        <div>
          <h3 className="mb-4">Прогресс по темам</h3>
          <div className="space-y-3">
            {decks.map((deck) => (
              <div key={deck.id} className="card">
                <div className="deck-row">
                  <div>
                    <h3 className="text-base">{deck.name}</h3>
                    <p className="text-sm text-muted">{deck.cardsCount} карточек</p>
                  </div>
                  <div className="text-right">
                    <div className="text-lg">{deck.progress}%</div>
                  </div>
                </div>

                <ProgressBar progress={deck.progress} color={deck.color} />

                <div className="mt-3 deck-levels">
                  <span className="text-muted">Уровни:</span>
                  <div className="deck-levels__list">
                    <span>0: {Math.round(deck.cardsCount * 0.3)}</span>
                    <span>1: {Math.round(deck.cardsCount * 0.3)}</span>
                    <span>2: {Math.round(deck.cardsCount * 0.2)}</span>
                    <span>3: {Math.round(deck.cardsCount * 0.2)}</span>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
        
        {/* Achievements */}
        <div>
          <h3 className="mb-4">Достижения</h3>
          <div className="achievements-grid">
            {statistics.achievements.map((achievement) => (
              <div
                key={achievement.id}
                className={`achievement ${achievement.unlocked ? '' : 'achievement--locked'}`}
              >
                <div className="achievement__icon">
                  {achievement.icon === 'trophy' && <Trophy size={24} className="text-white" />}
                  {achievement.icon === 'target' && <Target size={24} className="text-white" />}
                  {achievement.icon === 'zap' && <Zap size={24} className="text-white" />}
                </div>
                <span className="text-xs">{achievement.title}</span>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\study\StudyFlowStateContainer.tsx
==============================

// src/screens/study/StudyFlowStateContainer.tsx
import React from 'react';
import type { DifficultyRating, StudyCard, StudyMode } from '../../types';
import type { PersistedSession } from '../../utils/sessionStore';
import { ApiClient } from '../../api/client';
import { saveSession, clearSession } from '../../utils/sessionStore';

import { useStudySession } from '../../hooks/useStudySession';
import { useResumeCandidate } from './hooks/useResumeCandidate';
import { useStudyLauncher } from './hooks/useStudyLauncher';
import { StudyFlowView } from './StudyFlowView';

export type StudyController = {
  // resume card on dashboard
  resumeCandidate: PersistedSession | null;
  onResume: () => void;
  onDiscardResume: () => void;

  // запуск study (то, что ждёт HomeTabContainer / DeckDetailsScreen)
  onStartReviewStudy: () => Promise<void>;
  onStartDeckStudy: (deckId: string, mode: StudyMode, limit?: number) => Promise<void>;
  onResumeDeckSession: (saved: PersistedSession) => void;
  onRestartDeckSession: (deckId: string) => void;

  // чтобы App мог скрывать BottomNav при активном study
  isStudying: boolean;
};

type Props = {
  onExitToHome: () => void;   // например: () => setActiveTab('home')
  onRated: () => void;        // сюда передадим refreshStats из App
  children: (api: StudyController) => React.ReactNode;
};

export function StudyFlowStateContainer({ onExitToHome, onRated, children }: Props) {
  const [isStudying, setIsStudying] = React.useState(false);
  const [loadingDeckCards, setLoadingDeckCards] = React.useState(false);
  const showStudy = isStudying || loadingDeckCards;

  const [sessionMode, setSessionMode] = React.useState<'deck' | 'review'>('review');
  const [sessionKey, setSessionKey] = React.useState<'review' | `deck:${string}`>('review');
  const [activeDeckId, setActiveDeckId] = React.useState<string | null>(null);

  const [deckCards, setDeckCards] = React.useState<StudyCard[]>([]);
  const [sessionIndex, setSessionIndex] = React.useState(0);

  const { cards, currentIndex, isCompleted, rateCard, skipCard, resetSession } =
    useStudySession(deckCards, sessionIndex);

  const {
    resumeCandidate,
    setResumeCandidate,
    resumeLastSession: onResume,
    discardResume: onDiscardResume,
  } = useResumeCandidate({
    isStudying,
    loadingDeckCards,
    sessionKey,
    sessionMode,
    activeDeckId,
    deckCards,
    currentIndex,
    setIsStudying,
    setSessionMode,
    setSessionKey,
    setActiveDeckId,
    setSessionIndex,
    setDeckCards,
  });

  const launcherInput = React.useMemo(() => ({
    setLoadingDeckCards,
    setDeckCards,
    setActiveDeckId,
    setIsStudying,
    setSessionMode,
    setSessionKey,
    setSessionIndex,
  }), []);

  const {
    startDeckStudy: onStartDeckStudy,
    startReviewStudy: onStartReviewStudy,
    resumeDeckSession: onResumeDeckSession,
    restartDeckSession: onRestartDeckSession,
  } = useStudyLauncher(launcherInput);

  React.useEffect(() => {
    if (!isStudying) return;
    setSessionIndex(currentIndex);
  }, [currentIndex, isStudying]);

  React.useEffect(() => {
    if (!isStudying) return;
    if (!isCompleted) return;

    clearSession(sessionKey);
    setResumeCandidate(null);

    setIsStudying(false);
    setDeckCards([]);
    setSessionIndex(0);
    resetSession();
    onExitToHome();
  }, [isCompleted, isStudying, sessionKey, resetSession, onExitToHome, setResumeCandidate]);

  const handleLevelUp = async () => {
    const card = cards[currentIndex];
    if (!card) return;
    const r = await ApiClient.levelUp(card.id);
    setDeckCards(prev => prev.map(c => (c.id === card.id ? { ...c, activeLevel: r.active_level } : c)));
  };

  const handleLevelDown = async () => {
    const card = cards[currentIndex];
    if (!card) return;
    const r = await ApiClient.levelDown(card.id);
    setDeckCards(prev => prev.map(c => (c.id === card.id ? { ...c, activeLevel: r.active_level } : c)));
  };

  const handleRemoveFromProgress = async () => {
    const card = cards[currentIndex];
    if (!card) return;
    await ApiClient.deleteCardProgress(card.id);
    skipCard();
  };

  const handleRate = async (rating: DifficultyRating) => {
    await rateCard(rating);
    onRated(); // = refreshStats()
  };

  const handleCloseStudy = () => {
    if (deckCards.length > 0) {
      const snap: PersistedSession = {
        key: sessionKey,
        mode: sessionMode,
        activeDeckId,
        deckCards,
        currentIndex,
        isStudying: true,
        savedAt: Date.now(),
      };
      saveSession(snap);
      setResumeCandidate(snap);
    }

    setIsStudying(false);
    setDeckCards([]);
    setSessionIndex(0);
    resetSession();
    onExitToHome();
  };

    return (
        <>
        {showStudy ? (
            <StudyFlowView
                isStudying={showStudy}
                loadingDeckCards={loadingDeckCards}
                deckCards={deckCards}
                cards={cards}
                currentIndex={currentIndex}
                isCompleted={isCompleted}
                onRate={handleRate}
                onLevelUp={handleLevelUp}
                onLevelDown={handleLevelDown}
                onSkip={skipCard}
                onRemoveFromProgress={handleRemoveFromProgress}
                onClose={handleCloseStudy}
                onBackToHome={handleCloseStudy}
            />
        ) : (
            children({
                resumeCandidate,
                onResume,
                onDiscardResume,
                onStartReviewStudy,
                onStartDeckStudy,
                onResumeDeckSession,
                onRestartDeckSession,
                isStudying,
            })
        )}
        </>
    );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\study\StudyFlowView.tsx
==============================

// src/screens/study/StudyFlowView.tsx
import React from 'react';
import type { DifficultyRating, StudyCard } from '../../types';
import { StudySession } from './session/StudySession';

import './StudyFlow.css';

type Props = {
  isStudying: boolean;
  loadingDeckCards: boolean;
  deckCards: StudyCard[];

  cards: StudyCard[];
  currentIndex: number;
  isCompleted: boolean;

  onRate: (r: DifficultyRating) => void;
  onLevelUp: () => void;
  onLevelDown: () => void;
  onSkip: () => void;
  onRemoveFromProgress: () => void;
  onClose: () => void;

  onBackToHome: () => void; // когда нет карточек / completed
};

export function StudyFlowView(props: Props) {
  if (!props.isStudying) return null;

  if (props.loadingDeckCards) {
    return (
      <div className="study-flow">
        <div className="study-flow__center">
          <div className="study-flow__muted">Загрузка карточек…</div>
        </div>
      </div>
    );
  }

  if (props.deckCards.length === 0) {
    return (
      <div className="study-flow">
        <div className="study-flow__center study-flow__center--padded">
          <div className="study-flow__card study-flow__card--narrow">
            <h2 className="study-flow__title">Нет карточек</h2>
            <p className="study-flow__text">В этой сессии нет карточек для изучения.</p>
            <button className="btn-primary study-flow__full-width" onClick={props.onBackToHome}>
              Вернуться
            </button>
          </div>
        </div>
      </div>
    );
  }

  if (props.isCompleted) {
    return (
      <div className="study-flow">
        <div className="study-flow__center study-flow__center--padded">
          <div className="study-flow__card study-flow__card--narrow">
            <div className="study-flow__emoji" aria-hidden="true">
              🎉
            </div>
            <h2 className="study-flow__title">Сессия завершена</h2>
            <p className="study-flow__text">Отличная работа! Ты прошёл все карточки.</p>
            <button className="btn-primary study-flow__full-width" onClick={props.onBackToHome}>
              Вернуться в меню
            </button>
          </div>
        </div>
      </div>
    );
  }

  if (props.cards.length === 0) {
    return (
      <div className="study-flow">
        <div className="study-flow__center">
          <div className="study-flow__muted">Нет карточек для изучения</div>
        </div>
      </div>
    );
  }

  return (
    <StudySession
      cards={props.cards}
      currentIndex={props.currentIndex}
      onRate={props.onRate}
      onLevelUp={props.onLevelUp}
      onLevelDown={props.onLevelDown}
      onClose={props.onClose}
      onSkip={props.onSkip}
      onRemoveFromProgress={props.onRemoveFromProgress}
    />
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\study\hooks\useResumeCandidate.ts
==============================

// src/hooks/useResumeCandidate.ts
import { useEffect, useState } from 'react';
import { clearSession, loadLastSession, saveSession, type PersistedSession } from '../../../utils/sessionStore';

type Input = {
  isStudying: boolean;
  loadingDeckCards: boolean;
  sessionKey: PersistedSession['key'];
  sessionMode: PersistedSession['mode'];
  activeDeckId: string | null;
  deckCards: PersistedSession['deckCards'];
  currentIndex: number;

  setIsStudying: (v: boolean) => void;
  setSessionMode: (v: PersistedSession['mode']) => void;
  setSessionKey: (v: PersistedSession['key']) => void;
  setActiveDeckId: (v: string | null) => void;
  setSessionIndex: (v: number) => void;
  setDeckCards: (v: PersistedSession['deckCards']) => void;
};

export function useResumeCandidate(input: Input) {
  const [resumeCandidate, setResumeCandidate] = useState<PersistedSession | null>(null);

  // initial load
  useEffect(() => {
    const saved = loadLastSession();
    if (!saved || !saved.isStudying) {
      setResumeCandidate(null);
      return;
    }
    setResumeCandidate(saved);
  }, []);

  // autosave while studying
  useEffect(() => {
    if (!input.isStudying) return;
    if (input.loadingDeckCards) return;
    if (input.deckCards.length === 0) return;

    saveSession({
      key: input.sessionKey,
      mode: input.sessionMode,
      activeDeckId: input.activeDeckId,
      deckCards: input.deckCards,
      currentIndex: input.currentIndex,
      isStudying: true,
      savedAt: Date.now(),
    });

    setResumeCandidate(loadLastSession());
  }, [
    input.isStudying,
    input.loadingDeckCards,
    input.sessionKey,
    input.sessionMode,
    input.activeDeckId,
    input.deckCards,
    input.currentIndex,
  ]);

  const resumeLastSession = () => {
    const saved = resumeCandidate;
    if (!saved) return;

    input.setSessionMode(saved.mode);
    input.setSessionKey(saved.key);
    input.setActiveDeckId(saved.activeDeckId);
    input.setSessionIndex(saved.currentIndex ?? 0);
    input.setDeckCards(saved.deckCards ?? []);
    input.setIsStudying(true);

    setResumeCandidate(null);
  };

  const discardResume = () => {
    if (!resumeCandidate) return;
    clearSession(resumeCandidate.key);
    setResumeCandidate(null);
  };

  return { resumeCandidate, setResumeCandidate, resumeLastSession, discardResume };
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\study\hooks\useStudyLauncher.ts
==============================

// src/hooks/useStudyLauncher.ts
import { useCallback } from 'react';
import { ApiClient } from '../../../api/client';
import { toStudyCards } from '../../../utils/toStudyCards';
import { clearSession, type PersistedSession } from '../../../utils/sessionStore';
import type { StudyCard, StudyMode } from '../../../types';

type Input = {
  setLoadingDeckCards: (v: boolean) => void;
  setDeckCards: (v: StudyCard[]) => void;
  setActiveDeckId: (v: string | null) => void;

  setIsStudying: (v: boolean) => void;

  setSessionMode: (v: 'deck' | 'review') => void;
  setSessionKey: (v: 'review' | `deck:${string}`) => void;
  setSessionIndex: (v: number) => void;
};

export function useStudyLauncher(input: Input) {
  const startDeckStudy = useCallback(
    async (deckId: string, mode: StudyMode, limit?: number) => {
      const key = `deck:${deckId}` as const;

      const seed =
        mode === 'random' || mode === 'new_random'
          ? Date.now() % 1_000_000_000
          : undefined;

      const limitNormalized =
        mode === 'new_random' || mode === 'new_ordered'
          ? Math.max(1, Math.min(200, Math.trunc(Number.isFinite(Number(limit)) ? Number(limit) : 20)))
          : undefined;

      try {
        input.setLoadingDeckCards(true);

        const res = await ApiClient.getStudyCards(deckId, {
          mode,
          seed,
          limit: limitNormalized,
        });

        input.setDeckCards(res.cards);
        input.setActiveDeckId(deckId);
        input.setSessionMode('deck');
        input.setSessionKey(key);
        input.setSessionIndex(0);

        if (res.cards.length > 0) input.setIsStudying(true);
      } finally {
        input.setLoadingDeckCards(false);
      }
    },
    [input]
  );

  const startReviewStudy = useCallback(async () => {
    try {
      input.setLoadingDeckCards(true);

      const items = await ApiClient.getReviewSession(20);
      input.setDeckCards(toStudyCards(items));
      input.setActiveDeckId(null);

      input.setIsStudying(true);
      input.setSessionMode('review');
      input.setSessionKey('review');
      input.setSessionIndex(0);
    } finally {
      input.setLoadingDeckCards(false);
    }
  }, [input]);

  const resumeDeckSession = useCallback(
    (saved: PersistedSession) => {
      input.setSessionMode(saved.mode);
      input.setSessionKey(saved.key);
      input.setActiveDeckId(saved.activeDeckId);
      input.setSessionIndex(saved.currentIndex ?? 0);
      input.setDeckCards(saved.deckCards ?? []);
      input.setIsStudying(true);
    },
    [input]
  );

  const restartDeckSession = useCallback((deckId: string) => {
    clearSession((`deck:${deckId}` as const));
  }, []);

  return { startDeckStudy, startReviewStudy, resumeDeckSession, restartDeckSession };
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\screens\study\session\StudySession.tsx
==============================

import React, { useEffect, useState } from 'react';
import { StudyCard, DifficultyRating, isMultipleChoice } from '../../../types';
import { FlipCard } from '../../../components/FlipCard';
import { RatingButton } from '../../../components/RatingButton';
import { Button } from '../../../components/Button/Button';
import { ProgressBar } from '../../../components/ProgressBar';
import { X, SkipForward, Trash2 } from 'lucide-react';
import { MarkdownView } from '../../../components/MarkdownView';

function getLevelIndex(l: any): number {
  return typeof l?.level_index === 'number' ? l.level_index : l?.levelindex;
}

export function StudySession({
  cards,
  currentIndex,
  onRate,
  onClose,
  onLevelUp,
  onLevelDown,
  onSkip,
  onRemoveFromProgress,
}: {
  cards: StudyCard[];
  currentIndex: number;
  onRate: (rating: DifficultyRating) => void;
  onClose: () => void;
  onLevelUp: () => void;
  onLevelDown: () => void;
  onSkip: () => void;
  onRemoveFromProgress: () => void;
}) {
  const [isFlipped, setIsFlipped] = useState(false);
  const [selectedOptionId, setSelectedOptionId] = useState<string | null>(null);
  const [timeLeftMs, setTimeLeftMs] = useState<number | null>(null);


  const currentCard = cards[currentIndex];
  if (!currentCard) {
    return (
      <div className="study-page flex items-center justify-center">
        <div className="text-muted">Карточки закончились</div>
      </div>
    );
  }

  const progress = (currentIndex / cards.length) * 100;

  const handleRate = (rating: DifficultyRating) => {
    setIsFlipped(false);
    setTimeout(() => onRate(rating), 300);
  };

  const handleFlip = () => setIsFlipped((v) => !v);

  const handleSkip = () => {
    setIsFlipped(false);
    onSkip();
  };

  const handleRemoveFromProgress = () => {
    const ok = window.confirm(
      'Удалить карточку из прогресса?\n\n' +
        'Она больше не будет отображаться в повторении. ' +
        'Вернуть её можно будет, начав изучение снова (прогресс начнётся заново).'
    );
    if (!ok) return;

    setIsFlipped(false);
    onRemoveFromProgress();
  };

  useEffect(() => {
    setIsFlipped(false);
    setSelectedOptionId(null);
  }, [currentCard?.id, currentCard?.activeLevel]);

  const level =
    (currentCard.levels as any[]).find((l) => getLevelIndex(l) === currentCard.activeLevel) ??
    currentCard.levels[0];

  const mcq = isMultipleChoice(currentCard) ? ((level as any)?.content as any) : null;
  const timerSec = typeof mcq?.timerSec === 'number' && mcq.timerSec > 0 ? mcq.timerSec : 0;

useEffect(() => {
  if (!currentCard) return;
  if (!isMultipleChoice(currentCard)) return;
  if (isFlipped) {
    setTimeLeftMs(null);
    return;
  }
  if (!timerSec) {
    setTimeLeftMs(null);
    return;
  }

  const endAt = Date.now() + timerSec * 1000;

  // чтобы сразу отрисовалось "timerSec"
  setTimeLeftMs(timerSec * 1000);

  const id = window.setInterval(() => {
    const left = endAt - Date.now();
    if (left <= 0) {
      window.clearInterval(id);
      setTimeLeftMs(0);
      setIsFlipped(true); // авто-переворот когда время вышло
      return;
    }
    setTimeLeftMs(left);
  }, 200);

  return () => window.clearInterval(id);
}, [currentCard?.id, currentCard?.activeLevel, timerSec, isFlipped]);

const renderMcqFront = () => {
  const c = mcq;
  if (!c) return null;

  const correctId = String(c.correctOptionId ?? "");
  const showResult = selectedOptionId !== null;
  const leftSec = timerSec > 0
  ? Math.max(0, Math.ceil(((timeLeftMs ?? timerSec * 1000) as number) / 1000))
  : 0;

const progressPct =
  timerSec > 0 && timeLeftMs != null
    ? Math.max(0, Math.min(100, (timeLeftMs / (timerSec * 1000)) * 100))
    : 100;


  return (
    <div className="mcq">
      <div className="mcq-question">
        <MarkdownView value={String(c.question ?? "")} />
      </div>

      <div className="mcq-options">
        {(c.options ?? []).map((opt: any) => {
          const optId = String(opt.id);

          const isSelected = selectedOptionId === optId;
          const isCorrect = optId === correctId;

          const className = [
            "mcq-option",
            showResult && isCorrect ? "mcq-option--correct" : "",
            showResult && isSelected && !isCorrect ? "mcq-option--wrong" : "",
          ]
            .join(" ")
            .trim();

          return (
            <button
              key={optId}
              type="button"
              className={className}
              disabled={isFlipped}
              onClick={(e) => {
                e.stopPropagation();
                setSelectedOptionId(optId);
                setIsFlipped(true);
              }}
            >
              <MarkdownView value={String(opt.text ?? "")} />
            </button>
          );
        })}
      </div>

      {timerSec > 0 ? (
        <div className="mcq-timer">
          <div className="mcq-timer-text">⏳ {leftSec}s</div>
          <div className="mcq-timer-bar">
            <div className="mcq-timer-fill" style={{ width: `${progressPct}%` }} />
          </div>
        </div>
      ) : null}
    </div>
  );
};


  const renderMcqBack = () => {
    if (!mcq) return null;

    const options: any[] = mcq.options ?? [];
    const correct = options.find((o) => String(o.id) === String(mcq.correctOptionId));
    const selected = options.find((o) => String(o.id) === String(selectedOptionId));

    return (
      <div style={{ width: '100%', maxWidth: 520 }}>
        <div style={{ marginBottom: 12 }}>
          <div style={{ opacity: 0.85, fontSize: 12, marginBottom: 6 }}>Правильный ответ</div>
          <MarkdownView value={String(correct?.text ?? '')} />
        </div>

        {selectedOptionId ? (
          <div style={{ marginBottom: 12 }}>
            <div style={{ opacity: 0.85, fontSize: 12, marginBottom: 6 }}>Вы выбрали</div>
            <MarkdownView value={String(selected?.text ?? '')} />
          </div>
        ) : null}

        {mcq.explanation ? (
          <div>
            <div style={{ opacity: 0.85, fontSize: 12, marginBottom: 6 }}>Пояснение</div>
            <MarkdownView value={String(mcq.explanation)} />
          </div>
        ) : null}
      </div>
    );
  };

  return (
    <div className="study-page">
      <div className="page__header py-4">
        <div className="page__header-inner">
          <div className="flex justify-between items-center mb-4">
            <button onClick={onClose} className="icon-btn" aria-label="Закрыть сессию" type="button">
              <X size={18} />
            </button>

            <span className="text-sm text-muted">
              {currentIndex + 1} / {cards.length}
            </span>

            <div className="flex items-center" style={{ columnGap: 32 }}>
              <button
                onClick={handleSkip}
                className="icon-btn"
                aria-label="Пропустить карточку"
                type="button"
              >
                <SkipForward size={18} />
              </button>

              <button
                onClick={handleRemoveFromProgress}
                className="icon-btn"
                aria-label="Удалить прогресс карточки"
                type="button"
              >
                <Trash2 size={18} />
              </button>
            </div>
          </div>

          <ProgressBar progress={progress} color="#FF9A76" />
        </div>
      </div>

      <div className="study__card-area">
        {isMultipleChoice(currentCard) ? (
          <FlipCard
            card={currentCard}
            isFlipped={isFlipped}
            onFlip={() => setIsFlipped((v) => !v)}
            disableFlipOnClick
            onLevelUp={onLevelUp}
            onLevelDown={onLevelDown}
            frontContent={renderMcqFront()}
            backContent={renderMcqBack()}
          />
        ) : (
          <FlipCard
            card={currentCard}
            isFlipped={isFlipped}
            onFlip={handleFlip}
            onLevelUp={onLevelUp}
            onLevelDown={onLevelDown}
          />
        )}
      </div>

      <div className="study__actions">
        {!isFlipped ? (
          <Button onClick={handleFlip} variant="primary" size="large" fullWidth>
            Показать ответ
          </Button>
        ) : (
          <div className="study__actions-inner">
            <div className="rating-row">
              <RatingButton rating="again" label="Снова" onClick={() => handleRate('again')} />
              <RatingButton rating="hard" label="Трудно" onClick={() => handleRate('hard')} />
              <RatingButton rating="good" label="Хорошо" onClick={() => handleRate('good')} />
              <RatingButton rating="easy" label="Легко" onClick={() => handleRate('easy')} />
            </div>
          </div>
        )}
      </div>
    </div>
  );
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\types\api.ts
==============================

import type { CardContent, PublicDeckSummary } from './index';

export type ApiCardLevelContent = {
  level_index: number;
  content: CardContent;
};

export type ApiCardSummary = {
  card_id: string;
  title: string;
  type: string;
  levels?: ApiCardLevelContent[];
};

export type ApiDeckWithCards = {
  deck: PublicDeckSummary;
  cards: ApiCardSummary[];
};

export type ApiLevelIn = {
  level_index: number;
  content: CardContent;
};

export type ApiReplaceLevelsRequest = {
  levels: ApiLevelIn[];
};


export type ApiCreateCardLevelOption = { id: string; text: string };

export type ApiCreateCardLevelRequest = {
  question: string;

  // flashcard
  answer?: string | null;

  // multiple_choice
  options?: ApiCreateCardLevelOption[] | null;
  correctOptionId?: string | null;
  explanation?: string | null;

  // ВАЖНО: на create у тебя timerSec >= 1, поэтому 0 не шлём (оставляем undefined)
  timerSec?: number;
};

export type ApiCreateCardRequest = {
  deck_id: string;
  title: string;
  type: string;
  levels: ApiCreateCardLevelRequest[];
};

export type ApiCreateCardResponse = {
  card_id: string;
  deck_id: string;
};




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\types\index.ts
==============================

export type StudyMode = 'random' | 'ordered' | 'new_random' | 'new_ordered';

export type CardType = "flashcard" | "multiple_choice";

export type FlashcardContent = {
  question: string;
  answer: string;
  // можно хранить, но пока не используем для flashcard
  timerSec?: number;
};

export type McqOption = { id: string; text: string };

export type MultipleChoiceContent = {
  question: string;
  options: McqOption[];
  correctOptionId: string;
  explanation?: string;
  timerSec?: number;
};

export type CardContent = FlashcardContent | MultipleChoiceContent;


export type UserGroupResponse = {
  user_group_id: string;
  kind: string;
  source_group_id: string | null;
  title: string;
  description: string | null;
  parent_id: string | null;
};

export type GroupCreatePayload = {
  title: string;
  description?: string | null;
  parent_id?: string | null;
};

export type Group = {
  id: string;              // user_group_id
  title: string;
  description: string | null;
  parent_id: string | null;
  kind: string;
  source_group_id: string | null;
};

export type PublicDeckSummary = {
  deck_id: string;
  title: string;
  description: string | null;
  color: string | null;
  owner_id: string;
  is_public: boolean;
  count_repeat: number;
  count_for_repeat: number;
  cards_count: number;
  completed_cards_count: number;
};


export interface CardLevel {
  levelindex: number;
  content: CardContent;
}


// helper’ы (удобно для StudySession/Create/Edit)
export function isMultipleChoice(card: StudyCard | null | undefined): boolean {
  return !!card && card.type === "multiple_choice";
}

export interface StudyCard {
  id: string;
  deckId: string;
  title: string;
  type: string;
  levels: CardLevel[];
  activeLevel: number;
}

export interface Deck {
  id: string;
  name: string;
  description: string;
  cardsCount: number;
  progress: number; // 0-100
  averageLevel: number; // 0-3
  color: string;
}

export interface Statistics {
  cardsStudiedToday: number;
  timeSpentToday: number; // minutes
  currentStreak: number; // days
  totalCards: number;
  weeklyActivity: number[]; // 7 days
  achievements: Achievement[];
}

export interface Achievement {
  id: string;
  title: string;
  description: string;
  icon: string;
  unlocked: boolean;
  progress?: number;
}

export type DifficultyRating = 'again' | 'hard' | 'good' | 'easy';



==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\utils\errorMessage.ts
==============================

import { ApiError } from '../api/client';

export function getErrorMessage(e: unknown): string {
  if (e instanceof ApiError) return e.detail ?? e.message;
  if (e instanceof Error) return e.message;
  if (typeof e === 'string') return e;
  return 'Неизвестная ошибка';
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\utils\latexDelimiters.ts
==============================

// src/utils/latexDelimiters.ts
export function convertBracketLatexToDollar(src: string): string {
  if (!src) return src;

  let text = src;

  // Блочные формулы: \[ ... \] -> $$ ... $$
  text = text.replace(/\\\[(.*?)\\\]/gs, (_match, inner) => {
    return `$$\n${inner}\n$$`;
  });

  // Инлайн-формулы: \( ... \) -> $...$
  text = text.replace(/\\\((.*?)\\\)/g, (_match, inner) => {
    return `$${inner}$`;
  });

  return text;
}




==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\utils\sessionStore.ts
==============================

import type { StudyCard } from '../types';

const STORAGE_KEY = 'mnemonicflow:sessions:v1';

export type SessionKey = `deck:${string}` | 'review';

export type PersistedSession = {
  key: SessionKey;
  mode: 'deck' | 'review';
  activeDeckId: string | null;
  deckCards: StudyCard[];
  currentIndex: number;
  isStudying: boolean;
  savedAt: number;
};

type SessionsStore = {
  lastActiveKey?: SessionKey;
  sessions: Record<string, PersistedSession>;
};

const loadStore = (): SessionsStore => {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return { sessions: {} };
  try {
    return JSON.parse(raw) as SessionsStore;
  } catch {
    return { sessions: {} };
  }
};

const saveStore = (store: SessionsStore) => {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(store));
};

export const makeSessionKey = (mode: 'deck' | 'review', deckId: string | null): SessionKey =>
  mode === 'deck' && deckId ? (`deck:${deckId}` as const) : 'review';

export const saveSession = (s: PersistedSession) => {
  const store = loadStore();
  store.sessions[s.key] = s;
  store.lastActiveKey = s.key;
  saveStore(store);
};

export const loadLastSession = (): PersistedSession | null => {
  const store = loadStore();
  const k = store.lastActiveKey;
  return k ? (store.sessions[k] ?? null) : null;
};

export const clearSession = (key: SessionKey) => {
  const store = loadStore();
  delete store.sessions[key];
  if (store.lastActiveKey === key) delete store.lastActiveKey;
  saveStore(store);
};

export const loadSession = (key: SessionKey): PersistedSession | null => {
  const store = loadStore();
  return store.sessions[key] ?? null;
};



==============================
FILE: C:\Users\nik\Desktop\mnemonic-flow\mnemonic-flow-frontend\src\utils\toStudyCards.ts
==============================

import type { StudyCard } from '../types';

export const toStudyCards = (items: any[]): StudyCard[] =>
  items.map((c: any) => ({
    id: c.card_id,
    deckId: c.deck_id,
    title: c.title,
    type: c.type,
    levels: c.levels ?? [],
    activeLevel: c.active_level ?? 0,
  }));




